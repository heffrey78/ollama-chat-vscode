"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BaseExecutor: () => BaseExecutor,
  BaseParser: () => BaseParser,
  BasePrompt: () => BasePrompt,
  BaseStateItem: () => BaseStateItem,
  ChatPrompt: () => ChatPrompt,
  CustomParser: () => CustomParser,
  DefaultState: () => DefaultState,
  DefaultStateItem: () => DefaultStateItem,
  LlmExecutorOpenAiFunctions: () => LlmExecutorOpenAiFunctions,
  OpenAiFunctionParser: () => OpenAiFunctionParser,
  TextPrompt: () => TextPrompt,
  createCallableExecutor: () => createCallableExecutor,
  createChatPrompt: () => createChatPrompt,
  createCoreExecutor: () => createCoreExecutor,
  createCustomParser: () => createCustomParser,
  createDialogue: () => createDialogue,
  createEmbedding: () => createEmbedding,
  createLlmExecutor: () => createLlmExecutor,
  createParser: () => createParser,
  createPrompt: () => createPrompt,
  createState: () => createState,
  createStateItem: () => createStateItem,
  default: () => src_default,
  useExecutors: () => useExecutors,
  useLlm: () => useLlm,
  utils: () => utils_exports
});
module.exports = __toCommonJS(src_exports);

// src/utils/modules/pick.ts
function pick(object, keys) {
  return keys.reduce((obj, key) => {
    if (object && object.hasOwnProperty(key)) {
      obj[key] = object[key];
    }
    return obj;
  }, {});
}
__name(pick, "pick");

// src/utils/modules/ensureInputIsObject.ts
function ensureInputIsObject(input) {
  if (input === null || typeof input === "undefined") {
    return {
      input
    };
  }
  switch (typeof input) {
    case "object": {
      if (Array.isArray(input)) {
        return {
          input
        };
      }
      return input;
    }
    default:
      return {
        input
      };
  }
}
__name(ensureInputIsObject, "ensureInputIsObject");

// src/utils/modules/uuid.ts
var import_uuid = require("uuid");

// src/executor/_metadata.ts
var _state;
var _ExecutorExecutionMetadataState = class _ExecutorExecutionMetadataState {
  constructor(items) {
    __privateAdd(this, _state, {
      start: null,
      end: null,
      input: void 0,
      handlerInput: void 0,
      handlerOutput: void 0,
      output: void 0,
      errorMessage: void 0,
      error: void 0,
      metadata: null
    });
    if (items) {
      this.setItem(items);
    }
  }
  setItem(items) {
    if (!items || typeof items !== "object" || Array.isArray(items)) {
      return this;
    }
    const keys = Object.keys(items);
    for (const key of keys) {
      const value = items[key];
      __privateGet(this, _state)[key] = value;
    }
    return this;
  }
  asPlainObject() {
    return Object.freeze({
      start: __privateGet(this, _state).start,
      end: __privateGet(this, _state).end,
      input: __privateGet(this, _state).input,
      handlerInput: __privateGet(this, _state).handlerInput,
      handlerOutput: __privateGet(this, _state).handlerOutput,
      output: __privateGet(this, _state).output,
      errorMessage: __privateGet(this, _state).errorMessage,
      error: __privateGet(this, _state).error,
      metadata: __privateGet(this, _state).metadata
    });
  }
};
_state = new WeakMap();
__name(_ExecutorExecutionMetadataState, "ExecutorExecutionMetadataState");
var ExecutorExecutionMetadataState = _ExecutorExecutionMetadataState;
function createMetadataState(items) {
  return new ExecutorExecutionMetadataState(items);
}
__name(createMetadataState, "createMetadataState");

// src/utils/const.ts
var hookOnComplete = `onComplete`;
var hookOnError = `onError`;
var hookOnSuccess = `onSuccess`;

// src/executor/_base.ts
var _BaseExecutor = class _BaseExecutor {
  constructor(name, type, options) {
    /**
    * @property id - internal id of the executor
    */
    __publicField(this, "id");
    /**
    * @property type - type of executor
    */
    __publicField(this, "type");
    /**
    * @property created - timestamp date created
    */
    __publicField(this, "created");
    /**
    * @property name - name of executor
    */
    __publicField(this, "name");
    /**
    * @property executions -
    */
    __publicField(this, "executions");
    __publicField(this, "traceId", null);
    /**
    * @property hooks - hooks to be ran during execution
    */
    __publicField(this, "hooks");
    __publicField(this, "allowedHooks", [
      hookOnComplete,
      hookOnError,
      hookOnSuccess
    ]);
    this.id = (0, import_uuid.v4)();
    this.type = type;
    this.name = name;
    this.created = (/* @__PURE__ */ new Date()).getTime();
    this.executions = 0;
    this.hooks = {
      onSuccess: [],
      onError: [],
      onComplete: []
    };
    if (options?.hooks) {
      this.setHooks(options.hooks);
    }
  }
  /**
  *
  * Used to filter the input of the handler
  * @param _input
  * @returns original input formatted for handler
  */
  async getHandlerInput(_input, _metadata, _options) {
    return ensureInputIsObject(_input);
  }
  /**
  *
  * Used to filter the output of the handler
  * @param _input
  * @returns output O
  */
  getHandlerOutput(out, _metadata, _options) {
    return out;
  }
  /**
  *
  * execute - Runs the executor
  * @param _input
  * @returns handler output
  */
  async execute(_input, _options) {
    this.executions++;
    const _metadata = createMetadataState({
      start: (/* @__PURE__ */ new Date()).getTime(),
      input: _input
    });
    try {
      const input = await this.getHandlerInput(_input, _metadata.asPlainObject(), _options);
      _metadata.setItem({
        handlerInput: input
      });
      let result = await this.handler(input, _options);
      _metadata.setItem({
        handlerOutput: result
      });
      const output = this.getHandlerOutput(result, _metadata.asPlainObject(), _options);
      _metadata.setItem({
        output
      });
      this.runHook("onSuccess", _metadata.asPlainObject());
      return output;
    } catch (error) {
      _metadata.setItem({
        error,
        errorMessage: error.message
      });
      this.runHook("onError", _metadata.asPlainObject());
      throw error;
    } finally {
      _metadata.setItem({
        end: (/* @__PURE__ */ new Date()).getTime()
      });
      this.runHook("onComplete", _metadata.asPlainObject());
    }
  }
  metadata() {
    return {};
  }
  getMetadata(metadata) {
    return Object.assign({}, this.metadata(), {
      traceId: this.getTraceId(),
      id: this.id,
      type: this.type,
      name: this.name,
      created: this.created,
      executions: this.executions,
      metadata
    });
  }
  runHook(hook, _metadata) {
    const { [hook]: hooks = [] } = pick(this.hooks, this.allowedHooks);
    for (const hookFn of [
      ...hooks
    ]) {
      if (typeof hookFn === "function") {
        try {
          hookFn(_metadata, this.getMetadata());
        } catch (error) {
        }
      }
    }
  }
  setHooks(hooks = {}) {
    const hookKeys = Object.keys(hooks);
    for (const hookKey of hookKeys.filter((k) => this.allowedHooks.includes(k))) {
      const hookInput = hooks[hookKey];
      if (hookInput) {
        const _hooks = Array.isArray(hookInput) ? hookInput : [
          hookInput
        ];
        for (const hook of _hooks) {
          if (hook && typeof hook === "function" && !this.hooks[hookKey].find((h) => h === hook)) {
            this.hooks[hookKey].push(hook);
          }
        }
      }
    }
    return this;
  }
  removeHook(eventName, fn) {
    if (typeof fn !== "function") return this;
    const lis = this.hooks[eventName];
    if (!lis) return this;
    for (let i = lis.length; i >= 0; i--) {
      if (lis[i] === fn) {
        lis.splice(i, 1);
        break;
      }
    }
    return this;
  }
  on(eventName, fn) {
    return this.setHooks({
      [eventName]: fn
    });
  }
  off(eventName, fn) {
    return this.removeHook(eventName, fn);
  }
  once(eventName, fn) {
    if (typeof fn !== "function") return this;
    const onceWrapper = /* @__PURE__ */ __name((...args) => {
      fn(...args);
      this.off(eventName, onceWrapper);
    }, "onceWrapper");
    this.hooks[eventName].push(onceWrapper);
    return this;
  }
  withTraceId(traceId) {
    this.traceId = traceId;
    return this;
  }
  getTraceId() {
    return this.traceId;
  }
};
__name(_BaseExecutor, "BaseExecutor");
var BaseExecutor = _BaseExecutor;

// src/utils/modules/inferFunctionName.ts
function inferFunctionName(func, defaultName) {
  const name = func?.name;
  if (name && typeof name === "string") {
    if (name.substring(0, 6) === "bound ") {
      return name.replace("bound ", "");
    } else {
      return name;
    }
  }
  var result = /^function\s+([\w\$]+)\s*\(/.exec(func.toString());
  return result ? result[1] : defaultName;
}
__name(inferFunctionName, "inferFunctionName");

// src/executor/core.ts
var _CoreExecutor = class _CoreExecutor extends BaseExecutor {
  constructor(fn, options) {
    const name = fn?.name ? fn.name : inferFunctionName(fn.handler, "anonymous-core-executor");
    super(name, "function-executor", options);
    __publicField(this, "_handler");
    this._handler = fn.handler.bind(null);
  }
  async handler(_input) {
    return this._handler.call(null, _input);
  }
};
__name(_CoreExecutor, "CoreExecutor");
var CoreExecutor = _CoreExecutor;

// src/parser/_base.ts
var _BaseParser = class _BaseParser {
  /**
  * Create a new BaseParser.
  * @param name - The name of the parser.
  * @param  options - options
  */
  constructor(name, options = {}, target = "text") {
    __publicField(this, "name");
    __publicField(this, "options");
    __publicField(this, "target", "text");
    this.name = name;
    this.target = target;
    if (options) {
      this.options = options;
    }
  }
};
__name(_BaseParser, "BaseParser");
var BaseParser = _BaseParser;
var _BaseParserWithJson = class _BaseParserWithJson extends BaseParser {
  /**
  * Create a new BaseParser.
  * @param name - The name of the parser.
  * @param  options - options
  */
  constructor(name, options) {
    super(name);
    __publicField(this, "schema");
    __publicField(this, "validateSchema");
    const { schema, validateSchema: validateSchema2 } = options;
    this.validateSchema = !!validateSchema2;
    if (schema) {
      this.schema = schema;
    }
  }
};
__name(_BaseParserWithJson, "BaseParserWithJson");
var BaseParserWithJson = _BaseParserWithJson;

// src/utils/index.ts
var utils_exports = {};
__export(utils_exports, {
  assert: () => assert,
  asyncCallWithTimeout: () => asyncCallWithTimeout,
  defineSchema: () => defineSchema,
  filterObjectOnSchema: () => filterObjectOnSchema,
  importHelpers: () => importHelpers,
  importPartials: () => importPartials,
  isObjectStringified: () => isObjectStringified,
  maybeParseJSON: () => maybeParseJSON,
  maybeStringifyJSON: () => maybeStringifyJSON,
  registerHelpers: () => registerHelpers,
  registerPartials: () => registerPartials,
  replaceTemplateString: () => replaceTemplateString,
  replaceTemplateStringAsync: () => replaceTemplateStringAsync
});

// src/utils/modules/assert.ts
function assert(condition, message) {
  if (condition === void 0 || condition === null || condition === false) {
    if (typeof message === "string") {
      throw new Error(message);
    } else if (message instanceof Error) {
      throw message;
    } else {
      throw new Error(`Assertion error`);
    }
  }
}
__name(assert, "assert");

// src/utils/modules/defineSchema.ts
var import_json_schema_to_ts = require("json-schema-to-ts");
function defineSchema(obj) {
  obj.additionalProperties = false;
  return (0, import_json_schema_to_ts.asConst)(obj);
}
__name(defineSchema, "defineSchema");

// src/utils/modules/handlebars/utils/importPartials.ts
function importPartials(_partials) {
  let partials2 = [];
  if (_partials) {
    const externalPartialKeys = Object.keys(_partials);
    for (const externalPartialKey of externalPartialKeys) {
      if (typeof externalPartialKey === "string") {
        partials2.push({
          name: externalPartialKey,
          template: _partials[externalPartialKey]
        });
      }
    }
  }
  return partials2;
}
__name(importPartials, "importPartials");

// src/utils/modules/handlebars/utils/importHelpers.ts
function importHelpers(_helpers) {
  let helpers = [];
  if (_helpers) {
    const externalHelperKeys = Object.keys(_helpers);
    for (const externalHelperKey of externalHelperKeys) {
      if (typeof externalHelperKey === "string") {
        helpers.push({
          name: externalHelperKey,
          handler: _helpers[externalHelperKey]
        });
      }
    }
  }
  return helpers;
}
__name(importHelpers, "importHelpers");

// src/utils/modules/handlebars/index.ts
var import_handlebars3 = __toESM(require("handlebars"));

// src/utils/modules/handlebars/helpers/index.ts
var helpers_exports = {};
__export(helpers_exports, {
  eq: () => eq,
  getKeyOr: () => getKeyOr,
  getOr: () => getOr,
  hbsInTemplate: () => hbsInTemplate,
  ifCond: () => ifCond,
  indentJson: () => indentJson,
  join: () => join,
  jsonSchemaExample: () => jsonSchemaExample,
  neq: () => neq,
  objectToList: () => objectToList,
  pluralize: () => pluralize
});

// src/utils/modules/replaceTemplateString.ts
function replaceTemplateString(templateString, substitutions = {}, configuration = {
  helpers: [],
  partials: []
}) {
  if (!templateString) return templateString || "";
  const tempHelpers = [];
  const tempPartials = [];
  if (Array.isArray(configuration.helpers)) {
    registerHelpers(configuration.helpers, hbs);
    tempHelpers.push(...configuration.helpers.map((a) => a.name));
  }
  if (Array.isArray(configuration.partials)) {
    registerPartials(configuration.partials, hbs);
    tempPartials.push(...configuration.partials.map((a) => a.name));
  }
  const template = hbs.compile(templateString);
  const res = template(substitutions, {
    allowedProtoMethods: {
      substring: true
    }
  });
  tempHelpers.forEach(function(n) {
    hbs.unregisterHelper(n);
  });
  tempPartials.forEach(function(n) {
    hbs.unregisterPartial(n);
  });
  return res;
}
__name(replaceTemplateString, "replaceTemplateString");

// src/utils/modules/handlebars/helpers/hbsInTemplate.ts
function hbsInTemplate(arg1) {
  const data = this;
  const replace = replaceTemplateString(arg1, data);
  return replace;
}
__name(hbsInTemplate, "hbsInTemplate");

// src/utils/modules/get.ts
function get(obj, path, defaultValue) {
  if (obj == null || path === "" || Array.isArray(path) && path.length === 0) {
    return defaultValue;
  }
  const pathString = Array.isArray(path) ? path.join(".") : path;
  const travel = /* @__PURE__ */ __name((regexp) => pathString.split(regexp).filter(Boolean).reduce((res, key) => res !== null && res !== void 0 ? res[key] : res, obj), "travel");
  const result = travel(/[,[\]]+?/) || travel(/[,[\].]+?/);
  return result === void 0 || result === obj ? defaultValue : result === null ? defaultValue : result;
}
__name(get, "get");

// src/utils/modules/handlebars/helpers/getKeyOr.ts
function getKeyOr(key, arg2) {
  const res = get(this, key);
  return typeof res !== "undefined" && res !== "" ? res : arg2;
}
__name(getKeyOr, "getKeyOr");

// src/utils/modules/handlebars/helpers/getOr.ts
function getOr(arg1, arg2) {
  return typeof arg1 !== "undefined" && arg1 !== "" ? arg1 : arg2;
}
__name(getOr, "getOr");

// src/utils/modules/handlebars/helpers/indentJson.ts
function indentJson(arg1, collapse = "false") {
  if (typeof arg1 !== "object") {
    return replaceTemplateString(arg1 || "", this);
  }
  const replaced = maybeParseJSON(replaceTemplateString(maybeStringifyJSON(arg1), this));
  if (collapse == "true") {
    return JSON.stringify(replaced);
  }
  return JSON.stringify(replaced, null, 2);
}
__name(indentJson, "indentJson");

// src/utils/modules/toNumber.ts
function toNumber(value) {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "string" && value.trim() !== "") {
    return Number(value);
  }
  return NaN;
}
__name(toNumber, "toNumber");

// src/utils/modules/filterObjectOnSchema.ts
function isObject(obj) {
  return obj === Object(obj);
}
__name(isObject, "isObject");
function getType(schemaType) {
  if (!Array.isArray(schemaType)) {
    return schemaType;
  }
  var typeArray = schemaType;
  for (var i = 0; i < typeArray.length; i++) {
    var type = typeArray[i];
    if (type !== "null") {
      return type;
    }
  }
}
__name(getType, "getType");
function filterObjectOnSchema(schema, doc, detach, property) {
  let result;
  if (doc === null || doc === void 0) {
    return doc;
  }
  var type = getType(schema.type);
  if (type === "object" && isObject(doc) && schema.properties) {
    result = {};
    Object.keys(schema.properties).forEach(function(key) {
      var child = doc[key];
      var sp = schema.properties[key];
      var filteredChild = filterObjectOnSchema(sp, child, detach, property);
      if (property) {
        result[key] = get(sp, property, "");
      } else {
        if (filteredChild === void 0) {
          if (typeof sp?.default !== "undefined") {
            result[key] = get(sp, "default", "");
          } else {
            return;
          }
        } else {
          if (sp.type === "integer" || sp.type === "number") {
            result[key] = toNumber(filteredChild);
          } else if (sp.type === "boolean") {
            result[key] = !!filteredChild;
          } else {
            result[key] = filteredChild;
          }
        }
      }
    });
  } else if (type === "object" && isObject(doc) && detach) {
    return {};
  } else if (type === "array" && Array.isArray(doc) && schema.items) {
    result = [];
    doc.forEach(function(item) {
      result.push(filterObjectOnSchema(schema.items, item, detach, property));
    });
  } else {
    result = doc;
  }
  return result;
}
__name(filterObjectOnSchema, "filterObjectOnSchema");

// src/utils/modules/schemaExampleWith.ts
function schemaExampleWith(schema, property) {
  if (schema.type === "array") {
    return filterObjectOnSchema(schema, [
      {}
    ], void 0, property);
  }
  return filterObjectOnSchema(schema, {}, void 0, property);
}
__name(schemaExampleWith, "schemaExampleWith");

// src/utils/modules/handlebars/helpers/jsonSchemaExample.ts
function jsonSchemaExample(key, prop, collapse) {
  const schema = get(this, key);
  if (schema && schema.type) {
    const result = schemaExampleWith(schema, prop);
    if (typeof result !== "object") {
      return "";
    }
    const replaced = maybeParseJSON(replaceTemplateString(maybeStringifyJSON(result), this));
    if (collapse == "true") {
      return JSON.stringify(replaced);
    }
    return JSON.stringify(replaced, null, 2);
  }
  return "";
}
__name(jsonSchemaExample, "jsonSchemaExample");

// src/utils/modules/handlebars/helpers/pluralize.ts
function pluralize(arg1, arg2) {
  const [singular, plural] = arg1.split("|");
  return arg2 > 1 ? plural : singular;
}
__name(pluralize, "pluralize");

// src/utils/modules/handlebars/helpers/eq.ts
function eq(arg1 = "", arg2 = "", options) {
  const isArr = arg2.toString().split(",").map((a) => a.trim());
  return isArr.includes(arg1) ? options.fn(this) : options.inverse(this);
}
__name(eq, "eq");

// src/utils/modules/handlebars/helpers/neq.ts
function neq(arg1 = "", arg2 = "", options) {
  const isArr = arg2.toString().split(",").map((a) => a.trim());
  return !isArr.includes(arg1) ? options.fn(this) : options.inverse(this);
}
__name(neq, "neq");

// src/utils/modules/handlebars/helpers/ifCond.ts
function ifCond(v1, operator, v2, options) {
  switch (operator) {
    case "==":
      return v1 == v2 ? options.fn(this) : options.inverse(this);
    case "===":
      return v1 === v2 ? options.fn(this) : options.inverse(this);
    case "!=":
      return v1 != v2 ? options.fn(this) : options.inverse(this);
    case "!==":
      return v1 !== v2 ? options.fn(this) : options.inverse(this);
    case "<":
      return v1 < v2 ? options.fn(this) : options.inverse(this);
    case "<=":
      return v1 <= v2 ? options.fn(this) : options.inverse(this);
    case ">":
      return v1 > v2 ? options.fn(this) : options.inverse(this);
    case ">=":
      return v1 >= v2 ? options.fn(this) : options.inverse(this);
    case "&&":
      return v1 && v2 ? options.fn(this) : options.inverse(this);
    case "||":
      return v1 || v2 ? options.fn(this) : options.inverse(this);
    default:
      return options.inverse(this);
  }
}
__name(ifCond, "ifCond");

// src/utils/modules/handlebars/helpers/objectToList.ts
function objectToList(arg = {}) {
  return Object.keys(arg).map((key) => `- ${key}: ${arg[key]}`).join("\n");
}
__name(objectToList, "objectToList");

// src/utils/modules/handlebars/helpers/join.ts
function join(array) {
  if (typeof array === "string") return array;
  if (!Array.isArray(array)) return "";
  return array.join(", ");
}
__name(join, "join");

// src/utils/modules/handlebars/templates/index.ts
var MarkdownCode = `{{#if code}}\`\`\`{{#if language}}{{language}}{{/if}}
{{{code}}}
\`\`\`{{/if}}`;
var ThoughtActionResult = `
{{#if title}}{{#if attributes.stepsTaken.length}}{{title}}
{{/if}}{{/if}}
{{#each attributes.stepsTaken as | step |}}
{{#if step.thought}}Thought: {{step.result}}{{/if}}
{{#if step.result}}Action: {{step.action}}{{/if}}
{{#if step.result}}Result: {{step.result}}{{/if}}
{{/each}}`;
var ChatConversationHistory = `{{~#if title}}{{~#if chat_history.length}}{{title}}
{{~/if}}{{~/if}}
{{#each chat_history as | item |}}
{{~#eq item.role 'user'}}{{#if @last}}{{../mostRecentRolePrefix}}{{../userName}}{{../mostRecentRoleSuffix}}{{else}}{{../userName}}{{/if}}: {{#if @last}}{{../mostRecentMessagePrefix}}{{/if}}{{{item.content}}}{{#if @last}}{{../mostRecentMessageSuffix}}{{/if}}
{{/eq}}
{{~#eq item.role 'assistant'}}{{#if @last}}{{../mostRecentRolePrefix}}{{../assistantName}}{{../mostRecentRoleSuffix}}{{else}}{{../assistantName}}{{/if}}: {{#if @last}}{{../mostRecentMessagePrefix}}{{/if}}{{{item.content}}}{{#if @last}}{{../mostRecentMessageSuffix}}{{/if}}
{{/eq}}
{{~#eq item.role 'system'}}{{../systemName}}: {{{item.content}}}
{{/eq}}
{{~/each}}`;
var DialogueHistory = `{{>ChatConversationHistory title=title chat_history=(getKeyOr key []) assistantName=(getOr assistant 'Assistant') userName=(getOr user 'User') systemName=(getOr system 'System') mostRecentRolePrefix=mostRecentRolePrefix mostRecentRoleSuffix=mostRecentRoleSuffix mostRecentMessagePrefix=mostRecentMessagePrefix mostRecentMessageSuffix=mostRecentMessageSuffix}}`;
var SingleChatMessage = `{{~#eq role 'user'}}{{getOr name 'User'}}: {{{content}}}{{~/eq}}
{{~#eq role 'assistant'}}{{getOr assistant 'Assistant'}}: {{{content}}}{{~/eq}}
{{~#eq role 'system'}}{{getOr system 'System'}}: {{{content}}}{{~/eq}}`;
var ThoughtsAndObservations = `{{~#each thoughts as | step |}}
{{~#if step.thought}}Thought: {{{step.thought}}}
{{/if}}
{{~#if step.observation}}Observation: {{{step.observation}}}
{{/if}}
{{~/each}}`;
var JsonSchema = `{{#if (getKeyOr key false)}}
\`\`\`json
{{{indentJson (getKeyOr key) collapse}}}
\`\`\`
{{~/if}}`;
var JsonSchemaExampleJson = `{{#if (getOr key false)}}
\`\`\`json
{{{jsonSchemaExample key (getOr property '') collapse}}}
\`\`\`
{{~/if}}`;
var partials = {
  JsonSchema,
  JsonSchemaExampleJson,
  MarkdownCode,
  DialogueHistory,
  SingleChatMessage,
  ChatConversationHistory,
  ThoughtsAndObservations,
  ThoughtActionResult
};

// src/utils/modules/isPromise.ts
function isPromise(value) {
  if (typeof value === "object" && value !== null && typeof value.then === "function") {
    return true;
  }
  return Object.prototype.toString.call(value) === "[object AsyncFunction]";
}
__name(isPromise, "isPromise");

// src/utils/modules/handlebars/utils/makeHandlebarsInstanceAsync.ts
function makeHandlebarsInstanceAsync(hbs2) {
  var _a;
  const handlebars = hbs2.create();
  const asyncCompiler = (_a = class extends hbs2.JavaScriptCompiler {
    constructor() {
      super();
      this.compiler = asyncCompiler;
    }
    mergeSource(varDeclarations) {
      const sources = super.mergeSource(varDeclarations);
      sources.prepend("return (async () => {");
      sources.add(" })()");
      return sources;
    }
    appendToBuffer(source, location, explicit) {
      if (!Array.isArray(source)) {
        source = [
          source
        ];
      }
      source = this.source.wrap(source, location);
      if (this.environment.isSimple) {
        return [
          "return await ",
          source,
          ";"
        ];
      }
      if (explicit) {
        return [
          "buffer += await ",
          source,
          ";"
        ];
      }
      source.appendToBuffer = true;
      source.prepend("await ");
      return source;
    }
  }, __name(_a, "asyncCompiler"), _a);
  handlebars.JavaScriptCompiler = asyncCompiler;
  const _compile = handlebars.compile;
  const _template = handlebars.VM.template;
  const _escapeExpression = handlebars.escapeExpression;
  function escapeExpression(value) {
    if (isPromise(value)) {
      return value.then((v) => _escapeExpression(v));
    }
    return _escapeExpression(value);
  }
  __name(escapeExpression, "escapeExpression");
  function lookupProperty(containerLookupProperty) {
    return function(parent, propertyName) {
      if (isPromise(parent)) {
        if (typeof parent?.then === "function") {
          return parent.then((p) => containerLookupProperty(p, propertyName));
        }
        return parent().then((p) => containerLookupProperty(p, propertyName));
      }
      return containerLookupProperty(parent, propertyName);
    };
  }
  __name(lookupProperty, "lookupProperty");
  handlebars.template = function(spec) {
    spec.main_d = (_prog, _props, container, _depth, data, blockParams2, depths) => async (context) => {
      container.escapeExpression = escapeExpression;
      container.lookupProperty = lookupProperty(container.lookupProperty);
      if (depths.length == 0) {
        depths = [
          data.root
        ];
      }
      const v = spec.main(container, context, container.helpers, container.partials, data, blockParams2, depths);
      return v;
    };
    return _template(spec, handlebars);
  };
  handlebars.compile = function(template, options) {
    const compiled = _compile.apply(handlebars, [
      template,
      {
        ...options
      }
    ]);
    return function(context, execOptions) {
      context = context || {};
      return compiled.call(handlebars, context, execOptions);
    };
  };
  return handlebars;
}
__name(makeHandlebarsInstanceAsync, "makeHandlebarsInstanceAsync");

// src/utils/modules/handlebars/utils/appendContextPath.ts
function appendContextPath(contextPath, id) {
  return (contextPath ? `${contextPath}.` : "") + id;
}
__name(appendContextPath, "appendContextPath");

// src/utils/modules/handlebars/utils/blockParams.ts
function blockParams(params, ids) {
  return {
    ...params,
    ...{
      path: ids
    }
  };
}
__name(blockParams, "blockParams");

// src/utils/modules/extend.ts
function extend(obj, _source) {
  for (let i = 1; i < arguments.length; i++) {
    for (const key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }
  return obj;
}
__name(extend, "extend");

// src/utils/modules/handlebars/utils/createFrame.ts
function createFrame(object) {
  const frame = extend({}, object);
  frame._parent = object;
  return frame;
}
__name(createFrame, "createFrame");

// src/utils/modules/isEmpty.ts
function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  }
  if (Array.isArray(value) && value.length === 0) {
    return true;
  }
  return false;
}
__name(isEmpty, "isEmpty");

// src/utils/modules/handlebars/helpers/async/with.ts
async function withFnAsync(context, options) {
  if (arguments.length !== 2) {
    throw new Error("#with requires exactly one argument");
  }
  if (typeof context === "function") {
    context = context.call(this);
  } else if (isPromise(context)) {
    context = await context;
  }
  const { fn } = options;
  if (!isEmpty(context)) {
    let { data } = options;
    if (options.data && options.ids) {
      data = createFrame(options.data);
      data.contextPath = appendContextPath(options.data.contextPath, options.ids[0]);
    }
    return fn(context, {
      data,
      blockParams: blockParams([
        context
      ], [
        data && data.contextPath
      ])
    });
  }
  return options.inverse(this);
}
__name(withFnAsync, "withFnAsync");

// src/utils/modules/handlebars/helpers/async/if.ts
async function ifFnAsync(conditional, options) {
  if (arguments.length !== 2) {
    throw new Error("#if requires exactly one argument");
  }
  if (typeof conditional === "function") {
    conditional = conditional.call(this);
  } else if (isPromise(conditional)) {
    conditional = await conditional;
  }
  if (!options.hash.includeZero && !conditional || isEmpty(conditional)) {
    return options.inverse(this);
  } else {
    return options.fn(this);
  }
}
__name(ifFnAsync, "ifFnAsync");

// src/utils/modules/isReadableStream.ts
function isReadableStream(obj) {
  return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj._read === "function";
}
__name(isReadableStream, "isReadableStream");

// src/utils/modules/handlebars/helpers/async/each.ts
async function eachFnAsync(context, options) {
  if (!options) {
    throw new Error("Must pass iterator to #each");
  }
  const { fn } = options;
  const { inverse } = options;
  let i = 0;
  let data = {};
  let ret = [];
  let contextPath = "";
  if (options.data && options.ids) {
    contextPath = `${appendContextPath(options.data.contextPath, options.ids[0])}.`;
  }
  if (typeof context === "function") {
    context = context.call(this);
  }
  if (options.data) {
    data = createFrame(options.data);
  }
  async function execIteration(field, index, last) {
    if (data) {
      data.key = field;
      data.index = index;
      data.first = index === 0;
      data.last = !!last;
      if (contextPath) {
        data.contextPath = contextPath + field;
      }
    }
    ret.push(await fn(context[field], {
      data,
      blockParams: blockParams([
        context[field],
        field
      ], [
        contextPath + field,
        null
      ])
    }));
  }
  __name(execIteration, "execIteration");
  if (context && typeof context === "object") {
    if (isPromise(context)) {
      context = await context;
    }
    if (Array.isArray(context)) {
      for (let j = context.length; i < j; i++) {
        if (i in context) {
          await execIteration(i, i, i === context.length - 1);
        }
      }
    } else if (global.Symbol && context[global.Symbol.iterator]) {
      const newContext = [], iterator = context[global.Symbol.iterator]();
      for (let it = iterator.next(); !it.done; it = iterator.next()) {
        newContext.push(it.value);
      }
      context = newContext;
      for (let j = context.length; i < j; i++) {
        await execIteration(i, i, i === context.length - 1);
      }
    } else if (isReadableStream(context)) {
      const newContext = [];
      await new Promise((resolve, reject) => {
        context.on("data", (item) => {
          newContext.push(item);
        }).on("end", async () => {
          context = newContext;
          for (let j = context.length; i < j; i++) {
            await execIteration(i, i, i === context.length - 1);
          }
          resolve(true);
        }).once("error", (e) => reject(e));
      });
    } else {
      let priorKey;
      for (const key of Object.keys(context)) {
        if (priorKey !== void 0) {
          await execIteration(priorKey, i - 1);
        }
        priorKey = key;
        i++;
      }
      if (priorKey !== void 0) {
        await execIteration(priorKey, i - 1, true);
      }
    }
  }
  if (i === 0) {
    ret = inverse(this);
    ret = [
      inverse(this)
    ];
  }
  return ret.join("");
}
__name(eachFnAsync, "eachFnAsync");

// src/utils/modules/handlebars/helpers/async/unless.ts
async function unlessFnAsync(conditional, options) {
  if (arguments.length !== 2) {
    throw new Error("#unless requires exactly one argument");
  }
  return ifFnAsync.call(this, conditional, {
    fn: options.inverse,
    inverse: options.fn,
    hash: options.hash
  });
}
__name(unlessFnAsync, "unlessFnAsync");

// src/utils/modules/handlebars/helpers/async/async-helpers.ts
var asyncCoreOverrideHelpers = {
  if: ifFnAsync,
  with: withFnAsync,
  each: eachFnAsync,
  unless: unlessFnAsync
};

// src/utils/modules/getEnvironmentVariable.ts
function getEnvironmentVariable(name) {
  if (typeof process === "object" && process?.env) {
    return process.env[name];
  } else {
    return void 0;
  }
}
__name(getEnvironmentVariable, "getEnvironmentVariable");

// src/utils/modules/handlebars/index.ts
var __hbsAsync = makeHandlebarsInstanceAsync(import_handlebars3.default);
var __hbs = import_handlebars3.default;
function useHandlebars(hbsInstance, preferAsync = false) {
  hbsInstance.registerHelper("with", function(context, options) {
    return options.fn(context);
  });
  hbsInstance.registerHelper("cut", function(str, arg2) {
    return str.toString().replace(new RegExp(arg2, "g"), "");
  });
  hbsInstance.registerHelper("substring", function(str, start, end) {
    if (str.length > end) {
      return str.substring(start, end);
    } else {
      return str;
    }
  });
  hbsInstance.registerHelper("unless", function(conditional, options) {
    if (arguments.length !== 2) {
      throw new Error("#unless requires exactly one argument");
    }
    const ifFn = hbsInstance.helpers["if"];
    return ifFn(conditional, {
      fn: options.inverse,
      inverse: options.fn,
      hash: options.hash
    });
  });
  const helperKeys = Object.keys(helpers_exports);
  registerHelpers(helperKeys.map((a) => ({
    handler: helpers_exports[a],
    name: a
  })), hbsInstance);
  if (preferAsync) {
    const asyncHelperKeys = Object.keys(asyncCoreOverrideHelpers);
    registerHelpers(asyncHelperKeys.map((a) => ({
      handler: asyncCoreOverrideHelpers[a],
      name: a
    })), hbsInstance);
  }
  const helperPath = getEnvironmentVariable("CUSTOM_PROMPT_TEMPLATE_HELPERS_PATH");
  if (helperPath) {
    const externalHelpers = require(helperPath);
    registerHelpers(importHelpers(externalHelpers), hbsInstance);
  }
  const contextPartialKeys = Object.keys(partials);
  for (const contextPartialKey of contextPartialKeys) {
    hbsInstance.registerPartial(contextPartialKey, partials[contextPartialKey]);
  }
  const partialsPath = getEnvironmentVariable("CUSTOM_PROMPT_TEMPLATE_PARTIALS_PATH");
  if (typeof process === "object" && partialsPath) {
    const externalPartials = require(partialsPath);
    registerPartials(importPartials(externalPartials), hbsInstance);
  }
  return hbsInstance;
}
__name(useHandlebars, "useHandlebars");
var hbsAsync = useHandlebars(__hbsAsync);
var hbs = useHandlebars(__hbs);
function registerPartials(partials2, instance) {
  if (partials2 && Array.isArray(partials2)) {
    for (const partial of partials2) {
      if (partial.name && typeof partial.name === "string" && typeof partial.template === "string") {
        if (instance) {
          instance.registerPartial(partial.name, partial.template);
        } else {
          hbs.registerPartial(partial.name, partial.template);
          hbsAsync.registerPartial(partial.name, partial.template);
        }
      }
    }
  }
}
__name(registerPartials, "registerPartials");
function registerHelpers(helpers, instance) {
  if (helpers && Array.isArray(helpers)) {
    for (const helper of helpers) {
      if (helper.name && typeof helper.name === "string" && typeof helper.handler === "function") {
        if (instance) {
          instance.registerHelper(helper.name, helper.handler);
        } else {
          hbs.registerHelper(helper.name, helper.handler);
          hbsAsync.registerHelper(helper.name, helper.handler);
        }
      }
    }
  }
}
__name(registerHelpers, "registerHelpers");

// src/utils/modules/replaceTemplateStringAsync.ts
async function replaceTemplateStringAsync(templateString, substitutions = {}, configuration = {
  helpers: [],
  partials: []
}) {
  if (!templateString) return Promise.resolve(templateString || "");
  const tempHelpers = [];
  const tempPartials = [];
  if (Array.isArray(configuration.helpers)) {
    registerHelpers(configuration.helpers, hbsAsync);
    tempHelpers.push(...configuration.helpers.map((a) => a.name));
  }
  if (Array.isArray(configuration.partials)) {
    registerPartials(configuration.partials, hbsAsync);
    tempPartials.push(...configuration.partials.map((a) => a.name));
  }
  const template = hbsAsync.compile(templateString);
  const res = await template(substitutions, {
    allowedProtoMethods: {
      substring: true
    }
  });
  tempHelpers.forEach(function(n) {
    hbsAsync.unregisterHelper(n);
  });
  tempPartials.forEach(function(n) {
    hbsAsync.unregisterPartial(n);
  });
  return res;
}
__name(replaceTemplateStringAsync, "replaceTemplateStringAsync");

// src/utils/modules/asyncCallWithTimeout.ts
var asyncCallWithTimeout = /* @__PURE__ */ __name(async (asyncPromise, timeLimit = 1e4) => {
  let timeoutHandle;
  const timeoutPromise = new Promise((_resolve, reject) => {
    timeoutHandle = setTimeout(() => {
      return reject(new Error("Unable to perform action. Try again, or use another action."));
    }, timeLimit);
  });
  return Promise.race([
    asyncPromise,
    timeoutPromise
  ]).then((result) => {
    clearTimeout(timeoutHandle);
    return result;
  });
}, "asyncCallWithTimeout");

// src/utils/modules/json.ts
var maybeStringifyJSON = /* @__PURE__ */ __name((objOrMaybeString) => {
  if (!objOrMaybeString || typeof objOrMaybeString !== "object") {
    return objOrMaybeString;
  }
  try {
    const result = JSON.stringify(objOrMaybeString);
    return result;
  } catch (error) {
  }
  return "";
}, "maybeStringifyJSON");
var maybeParseJSON = /* @__PURE__ */ __name((objOrMaybeJSON) => {
  if (!objOrMaybeJSON) return {};
  if (typeof objOrMaybeJSON === "string") {
    try {
      const cleanMarkdown = helpJsonMarkup(objOrMaybeJSON);
      const result = JSON.parse(cleanMarkdown);
      if (typeof result === "object" && result !== null) {
        return result;
      }
    } catch (error) {
    }
  }
  if (typeof objOrMaybeJSON === "object" && objOrMaybeJSON !== null) {
    return objOrMaybeJSON;
  }
  return {};
}, "maybeParseJSON");
function isObjectStringified(maybeObject) {
  if (typeof maybeObject !== "string") return false;
  const isMaybeObject = maybeObject.substring(0, 1) === "{" && maybeObject.substring(maybeObject.length - 1, maybeObject.length) === "}";
  const isMaybeArray = maybeObject.substring(0, 1) === "[" && maybeObject.substring(maybeObject.length - 1, maybeObject.length) === "]";
  if (!isMaybeObject && !isMaybeArray) {
    return false;
  }
  let canDecode = false;
  try {
    JSON.parse(maybeObject);
    canDecode = true;
  } catch (error) {
    canDecode = false;
  }
  return canDecode;
}
__name(isObjectStringified, "isObjectStringified");
function helpJsonMarkup(str) {
  if (typeof str !== "string") {
    return str;
  }
  const input = str.trim();
  const markdownJsonStartsWith = "```json";
  const markdownJsonEndsWith = "```";
  if (input.substring(0, markdownJsonStartsWith.length) === markdownJsonStartsWith && input.substring(input.length - markdownJsonEndsWith.length, input.length) === markdownJsonEndsWith) {
    return str.substring(markdownJsonStartsWith.length, input.length - markdownJsonEndsWith.length)?.trim();
  }
  return str;
}
__name(helpJsonMarkup, "helpJsonMarkup");

// src/llm/output/_utils/getResultText.ts
function getResultText(content) {
  if (content.length === 1 && content.every((a) => a.type === "text")) {
    return content[0]?.text || "";
  }
  return "";
}
__name(getResultText, "getResultText");

// src/parser/parsers/OpenAiFunctionParser.ts
var _OpenAiFunctionParser = class _OpenAiFunctionParser extends BaseParser {
  constructor(options) {
    super("openAiFunction", options, "function_call");
    __publicField(this, "parser");
    this.parser = options.parser;
  }
  parse(text, _options) {
    const functionUse = text.find((a) => a.type === "function_use");
    if (functionUse && "name" in functionUse && "input" in functionUse) {
      return {
        name: functionUse.name,
        arguments: maybeParseJSON(functionUse.input)
      };
    }
    return this.parser.parse(getResultText(text));
  }
};
__name(_OpenAiFunctionParser, "OpenAiFunctionParser");
var OpenAiFunctionParser = _OpenAiFunctionParser;

// src/parser/parsers/StringParser.ts
var _StringParser = class _StringParser extends BaseParser {
  constructor(options) {
    super("string", options);
  }
  parse(text, _options) {
    assert(typeof text === "string", `Invalid input. Expected string. Received ${typeof text}.`);
    const parsed = text.toString();
    return parsed;
  }
};
__name(_StringParser, "StringParser");
var StringParser = _StringParser;

// src/parser/parsers/BooleanParser.ts
var _BooleanParser = class _BooleanParser extends BaseParser {
  constructor(options) {
    super("boolean", options);
  }
  parse(text) {
    assert(typeof text === "string", `Invalid input. Expected string. Received ${typeof text}.`);
    const clean = text.toLowerCase().trim();
    if (clean === "true") {
      return true;
    }
    return false;
  }
};
__name(_BooleanParser, "BooleanParser");
var BooleanParser = _BooleanParser;

// src/utils/modules/isFinite.ts
function isFinite(value) {
  return typeof value === "number" && Number.isFinite(value);
}
__name(isFinite, "isFinite");

// src/parser/parsers/NumberParser.ts
var _NumberParser = class _NumberParser extends BaseParser {
  constructor(options) {
    super("number", options);
  }
  parse(text) {
    const match = text.match(/\d/g);
    return match && isFinite(toNumber(match[0])) ? toNumber(match[0]) : -1;
  }
};
__name(_NumberParser, "NumberParser");
var NumberParser = _NumberParser;

// src/parser/_utils.ts
var import_jsonschema = require("jsonschema");
function enforceParserSchema(schema, parsed) {
  if (!schema || !parsed || typeof parsed !== "object") {
    return parsed;
  }
  return filterObjectOnSchema(schema, parsed);
}
__name(enforceParserSchema, "enforceParserSchema");
function validateParserSchema(schema, parsed) {
  if (!schema || !parsed || typeof parsed !== "object") {
    return null;
  }
  const validate = (0, import_jsonschema.validate)(parsed, schema);
  if (validate.errors.length) {
    return validate.errors;
  }
  return null;
}
__name(validateParserSchema, "validateParserSchema");

// src/parser/parsers/JsonParser.ts
var _JsonParser = class _JsonParser extends BaseParserWithJson {
  constructor(options = {}) {
    super("json", options);
  }
  parse(text, _attributes) {
    const parsed = maybeParseJSON(helpJsonMarkup(text));
    if (this.schema) {
      const enforce = enforceParserSchema(this.schema, parsed);
      if (this.validateSchema) {
        const valid = validateParserSchema(this.schema, enforce);
        if (valid && valid.length) {
          throw new Error(valid[0].message);
        }
      }
      return enforce;
    }
    return parsed;
  }
};
__name(_JsonParser, "JsonParser");
var JsonParser = _JsonParser;

// src/utils/modules/camelCase.ts
function camelCase(input) {
  if (!input) return input;
  input = input.replace(/[^a-zA-Z0-9_]+/g, " ").trim();
  const words = input.split(/\s+|_/);
  return words.map((word, index) => {
    if (index === 0) {
      return word.toLowerCase();
    } else {
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    }
  }).join("");
}
__name(camelCase, "camelCase");

// src/parser/parsers/ListToJsonParser.ts
var _ListToJsonParser = class _ListToJsonParser extends BaseParserWithJson {
  constructor(options = {}) {
    super("listToJson", options);
  }
  parse(text) {
    const lines = text.split("\n");
    const output = {};
    lines.forEach((line) => {
      const [key, value] = line.split(":");
      if (value) {
        output[camelCase(key)] = value.trim();
      }
    });
    if (this.schema) {
      const parsed = enforceParserSchema(this.schema, output);
      if (this?.validateSchema) {
        const valid = validateParserSchema(this.schema, parsed);
        if (valid && valid.length) {
          throw new Error(valid[0].message);
        }
      }
      return parsed;
    }
    return output;
  }
};
__name(_ListToJsonParser, "ListToJsonParser");
var ListToJsonParser = _ListToJsonParser;

// src/parser/parsers/ListToKeyValueParser.ts
var _ListToKeyValueParser = class _ListToKeyValueParser extends BaseParser {
  constructor(options) {
    super("listToKeyValue", options);
  }
  parse(text) {
    const lines = text.split("\n").map((s) => s.replace("- ", "").replace(/\'/g, "'"));
    let res = [];
    for (const line of lines) {
      const [key, value] = line.split(":");
      if (key && value) {
        res.push({
          key: key?.trim(),
          value: value?.trim()
        });
      }
    }
    return res;
  }
};
__name(_ListToKeyValueParser, "ListToKeyValueParser");
var ListToKeyValueParser = _ListToKeyValueParser;

// src/parser/parsers/CustomParser.ts
var _CustomParser = class _CustomParser extends BaseParser {
  /**
  * Creates a new CustomParser instance.
  * @param {string} name The name of the parser.
  * @param {any} parserFn The custom parsing function.
  */
  constructor(name, parserFn) {
    super(name);
    /**
    * Custom parsing function.
    * @type {any}
    */
    __publicField(this, "parserFn");
    this.parserFn = parserFn;
  }
  /**
  * Parses the text using the custom parsing function.
  * @param {string} text The text to be parsed.
  * @param {any} inputValues Additional input values for the parser function.
  * @returns {O} The parsed value.
  */
  parse(text, inputValues) {
    return this.parserFn.call(this, text, inputValues);
  }
};
__name(_CustomParser, "CustomParser");
var CustomParser = _CustomParser;

// src/parser/parsers/ListToArrayParser.ts
var _ListToArrayParser = class _ListToArrayParser extends BaseParser {
  constructor() {
    super("listToArray");
  }
  parse(text) {
    const lines = text.split("\n").map((s) => s.replace("- ", "").replace(/\'/g, "'"));
    return lines;
  }
};
__name(_ListToArrayParser, "ListToArrayParser");
var ListToArrayParser = _ListToArrayParser;

// src/parser/parsers/ReplaceStringTemplateParser.ts
var _ReplaceStringTemplateParser = class _ReplaceStringTemplateParser extends BaseParser {
  constructor(options) {
    super("replaceStringTemplate", options);
  }
  parse(text, attributes) {
    return replaceTemplateString(text, attributes);
  }
};
__name(_ReplaceStringTemplateParser, "ReplaceStringTemplateParser");
var ReplaceStringTemplateParser = _ReplaceStringTemplateParser;

// src/parser/parsers/MarkdownCodeBlocks.ts
var _MarkdownCodeBlocksParser = class _MarkdownCodeBlocksParser extends BaseParser {
  constructor(options) {
    super("markdownCodeBlocks", options);
  }
  parse(input) {
    const out = [];
    const regex = input.matchAll(new RegExp(/`{3}([\w]*)\n([\S\s]+?)\n`{3}/, "g"));
    for (const iterator of regex) {
      if (iterator) {
        const [_input, language, code] = iterator;
        out.push({
          language,
          code
        });
      }
    }
    return out;
  }
};
__name(_MarkdownCodeBlocksParser, "MarkdownCodeBlocksParser");
var MarkdownCodeBlocksParser = _MarkdownCodeBlocksParser;

// src/parser/parsers/MarkdownCodeBlock.ts
var _MarkdownCodeBlockParser = class _MarkdownCodeBlockParser extends BaseParser {
  constructor(options) {
    super("markdownCodeBlock", options);
  }
  parse(input) {
    const [block] = new MarkdownCodeBlocksParser().parse(input);
    return block;
  }
};
__name(_MarkdownCodeBlockParser, "MarkdownCodeBlockParser");
var MarkdownCodeBlockParser = _MarkdownCodeBlockParser;

// src/parser/parsers/StringExtractParser.ts
var _StringExtractParser = class _StringExtractParser extends BaseParser {
  constructor(options) {
    super("stringExtract", options);
    __publicField(this, "enum", []);
    __publicField(this, "ignoreCase");
    if (options?.enum) {
      this.enum.push(...options.enum);
    }
    if (options?.ignoreCase) {
      this.ignoreCase = true;
    }
  }
  parse(text) {
    assert(typeof text === "string", `Invalid input. Expected string. Received ${typeof text}.`);
    for (const option of this.enum) {
      const regex = this.ignoreCase ? new RegExp(option.toLowerCase(), "i") : new RegExp(option);
      if (regex.test(text)) {
        return option;
      }
    }
    return "";
  }
};
__name(_StringExtractParser, "StringExtractParser");
var StringExtractParser = _StringExtractParser;

// src/parser/_functions.ts
function createParser(type, options = {}) {
  switch (type) {
    case "json":
      return new JsonParser(options);
    case "markdownCodeBlocks":
      return new MarkdownCodeBlocksParser();
    case "markdownCodeBlock":
      return new MarkdownCodeBlockParser();
    case "listToArray":
      return new ListToArrayParser();
    case "listToJson":
      return new ListToJsonParser(options);
    case "listToKeyValue":
      return new ListToKeyValueParser();
    case "replaceStringTemplate":
      return new ReplaceStringTemplateParser();
    case "boolean":
      return new BooleanParser();
    case "number":
      return new NumberParser();
    case "stringExtract":
      return new StringExtractParser(options);
    case "string":
    default:
      return new StringParser();
  }
}
__name(createParser, "createParser");
function createCustomParser(name, parserFn) {
  return new CustomParser(name, parserFn);
}
__name(createCustomParser, "createCustomParser");

// src/executor/llm.ts
var _LlmExecutor = class _LlmExecutor extends BaseExecutor {
  constructor(llmConfiguration, options) {
    super(llmConfiguration.name || "anonymous-llm-executor", "llm-executor", options);
    __publicField(this, "llm");
    __publicField(this, "prompt");
    __publicField(this, "promptFn");
    __publicField(this, "parser");
    this.llm = llmConfiguration.llm;
    this.parser = llmConfiguration?.parser || new StringParser();
    if (typeof llmConfiguration.prompt === "function") {
      this.prompt = void 0;
      this.promptFn = llmConfiguration.prompt;
    } else {
      this.prompt = llmConfiguration.prompt;
      this.promptFn = null;
    }
  }
  async execute(_input, _options) {
    if (this?.parser instanceof JsonParser && this.parser.schema) {
      _options = Object.assign(_options || {}, {
        jsonSchema: this.parser.schema
      });
    }
    return super.execute(_input, _options);
  }
  async handler(_input, ..._args) {
    const call = await this.llm.call(_input, ..._args);
    return call;
  }
  async getHandlerInput(_input) {
    if (this.prompt) {
      if (isPromise(this.prompt.formatAsync)) {
        return await this.prompt.formatAsync(_input);
      } else {
        return this.prompt.format(_input);
      }
    }
    if (this.promptFn) {
      const prompt = this.promptFn(_input);
      const promptFormatted = prompt.format(_input);
      return promptFormatted;
    }
    throw new Error("Missing prompt");
  }
  getHandlerOutput(out, _metadata) {
    if (this.parser.target === "function_call") {
      const outToStr = out.getResultContent();
      return this.parser.parse(outToStr, _metadata);
    } else {
      const outToStr = out.getResultText();
      return this.parser.parse(outToStr, _metadata);
    }
  }
  metadata() {
    return {
      llm: this.llm.getMetadata()
    };
  }
  getTraceId() {
    if (this.traceId) {
      return this.traceId;
    }
    return this.llm.getTraceId();
  }
};
__name(_LlmExecutor, "LlmExecutor");
var LlmExecutor = _LlmExecutor;

// src/executor/_functions.ts
function createCoreExecutor(handler, options) {
  return new CoreExecutor({
    handler
  }, options);
}
__name(createCoreExecutor, "createCoreExecutor");
function createLlmExecutor(llmConfiguration, options) {
  return new LlmExecutor(llmConfiguration, options);
}
__name(createLlmExecutor, "createLlmExecutor");

// src/executor/llm-openai-function.ts
var _LlmExecutorOpenAiFunctions = class _LlmExecutorOpenAiFunctions extends LlmExecutor {
  constructor(llmConfiguration, options) {
    super(Object.assign({}, llmConfiguration, {
      parser: new OpenAiFunctionParser({
        parser: llmConfiguration.parser || new StringParser()
      })
    }), options);
  }
  async execute(_input, _options) {
    return super.execute(_input, _options);
  }
};
__name(_LlmExecutorOpenAiFunctions, "LlmExecutorOpenAiFunctions");
var LlmExecutorOpenAiFunctions = _LlmExecutorOpenAiFunctions;

// src/utils/modules/enforceResultAttributes.ts
function enforceResultAttributes(input) {
  if (!input) {
    return {
      result: input,
      attributes: {}
    };
  }
  if (typeof input === "object" && (Object.keys(input).length === 2 && "result" in input && "attributes" in input || Object.keys(input).length === 1 && ("result" in input || "attributes" in input))) {
    return input;
  }
  return {
    result: input,
    attributes: {}
  };
}
__name(enforceResultAttributes, "enforceResultAttributes");

// src/plugins/callable/callable.ts
var _CallableExecutor = class _CallableExecutor {
  constructor(options) {
    __publicField(this, "name");
    __publicField(this, "key");
    __publicField(this, "description");
    __publicField(this, "input");
    __publicField(this, "attributes");
    __publicField(this, "parameters");
    __publicField(this, "_handler");
    const defaults = {
      key: options.name
    };
    this.name = options.name;
    this.key = options?.key || defaults.key;
    this.description = options.description;
    this.input = options.input;
    this.parameters = options.parameters || {};
    this.attributes = options?.attributes || {};
    this._validateInput = options.validateInput;
    this._visibilityHandler = options?.visibilityHandler;
    if (options.handler instanceof BaseExecutor) {
      this._handler = options.handler;
    } else if (typeof options.handler === "function") {
      this._handler = createCoreExecutor(options.handler);
    } else {
      throw new Error("Invalid handler");
    }
  }
  async execute(input) {
    const response = await this._handler.execute(ensureInputIsObject(input));
    return enforceResultAttributes(response);
  }
  async validateInput(input) {
    try {
      if (typeof this._validateInput === "function") {
        const response = await this._validateInput(ensureInputIsObject(input), this._handler.getMetadata());
        return enforceResultAttributes(response);
      }
      return {
        result: true,
        attributes: {}
      };
    } catch (error) {
      return {
        result: false,
        attributes: {
          error: error.message
        }
      };
    }
  }
  visibilityHandler(input, attributes) {
    if (typeof this._visibilityHandler === "function") {
      return this._visibilityHandler(input, this._handler.getMetadata(), attributes);
    }
    return true;
  }
};
__name(_CallableExecutor, "CallableExecutor");
var CallableExecutor = _CallableExecutor;
var _UseExecutorsBase = class _UseExecutorsBase {
  constructor(handlers) {
    __publicField(this, "handlers", []);
    this.handlers = handlers;
  }
  hasFunction(name) {
    return !!this.getFunction(name);
  }
  getFunction(name) {
    return this.handlers.find((a) => a.name === name);
  }
  getFunctions() {
    return [
      ...this.handlers
    ];
  }
  getVisibleFunctions(_input, _attributes = {}) {
    const handlers = this.getFunctions();
    return handlers.filter((a) => typeof a.visibilityHandler === "undefined" || typeof a.visibilityHandler === "function" && a.visibilityHandler(_input, _attributes));
  }
  async callFunction(name, input) {
    try {
      const handler = this.getFunction(name);
      assert(handler, `[invalid handler] The handler (${name}) does not exist.`);
      const result = await handler.execute(ensureInputIsObject(input));
      return result;
    } catch (error) {
      return error.message;
    }
  }
  async validateFunctionInput(name, input) {
    try {
      const handler = this.getFunction(name);
      assert(handler, `[invalid handler] The handler (${name}) does not exist.`);
      const result = await handler.validateInput(ensureInputIsObject(input));
      return result;
    } catch (error) {
      return {
        result: false,
        attributes: {
          error: error.message
        }
      };
    }
  }
};
__name(_UseExecutorsBase, "UseExecutorsBase");
var UseExecutorsBase = _UseExecutorsBase;

// src/plugins/callable/index.ts
function createCallableExecutor(options) {
  return new CallableExecutor(options);
}
__name(createCallableExecutor, "createCallableExecutor");
var _UseExecutors = class _UseExecutors extends UseExecutorsBase {
  constructor(handlers) {
    super(handlers);
  }
};
__name(_UseExecutors, "UseExecutors");
var UseExecutors = _UseExecutors;
function useExecutors(executors) {
  return new UseExecutors(executors.map((e) => {
    if (e instanceof CallableExecutor) return e;
    return createCallableExecutor(e);
  }));
}
__name(useExecutors, "useExecutors");

// src/utils/modules/deepClone.ts
function deepClone(obj) {
  if (obj === null || obj === void 0) return obj;
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => deepClone(item));
  }
  if (typeof obj === "object" && obj !== null) {
    const cloneObj = {};
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        cloneObj[key] = deepClone(obj[key]);
      }
    }
    return cloneObj;
  }
  return obj;
}
__name(deepClone, "deepClone");

// src/llm/_utils.withDefaultModel.ts
function withDefaultModel(obj1, model) {
  const copy = deepClone(obj1);
  if (copy.options.model) {
    copy.options.model.default = model;
  } else {
    copy.options.model = {
      default: model
    };
  }
  if (copy.mapBody.model) {
    copy.mapBody.model.default = model;
  } else {
    copy.mapBody.model = {
      key: "model",
      default: model
    };
  }
  return copy;
}
__name(withDefaultModel, "withDefaultModel");

// src/llm/config/openai/index.ts
var openAiChatV1 = {
  key: "openai.chat.v1",
  provider: "openai.chat",
  endpoint: `https://api.openai.com/v1/chat/completions`,
  options: {
    prompt: {},
    topP: {},
    useJson: {},
    openAiApiKey: {
      default: getEnvironmentVariable("OPENAI_API_KEY")
    }
  },
  method: "POST",
  headers: `{"Authorization":"Bearer {{openAiApiKey}}", "Content-Type": "application/json" }`,
  mapBody: {
    prompt: {
      key: "messages",
      sanitize: /* @__PURE__ */ __name((v) => {
        if (typeof v === "string") {
          return [
            {
              role: "user",
              content: v
            }
          ];
        }
        return v;
      }, "sanitize")
    },
    model: {
      key: "model"
    },
    topP: {
      key: "top_p"
    },
    useJson: {
      key: "response_format.type",
      sanitize: /* @__PURE__ */ __name((v) => v ? "json_object" : "text", "sanitize")
    }
  }
};
var openAiChatMockV1 = {
  key: "openai.chat-mock.v1",
  provider: "openai.chat-mock",
  endpoint: `http://localhost`,
  options: {
    prompt: {},
    topP: {},
    useJson: {},
    openAiApiKey: {
      default: getEnvironmentVariable("OPENAI_API_KEY_MOCK")
    }
  },
  method: "POST",
  headers: `{"Authorization":"Bearer {{openAiApiKey}}", "Content-Type": "application/json" }`,
  mapBody: {
    prompt: {
      key: "messages"
    },
    model: {
      key: "model"
    },
    topP: {
      key: "top_p"
    },
    useJson: {
      key: "response_format.type",
      sanitize: /* @__PURE__ */ __name((v) => v ? "json_object" : "text", "sanitize")
    }
  }
};
var openai = {
  "openai.chat.v1": openAiChatV1,
  "openai.chat-mock.v1": openAiChatMockV1,
  "openai.gpt-4o": withDefaultModel(openAiChatV1, "gpt-4o"),
  "openai.gpt-4o-mini": withDefaultModel(openAiChatV1, "gpt-4o-mini")
};

// src/llm/config/anthropic/index.ts
var ANTORPIC_VERSION = "2023-06-01";
function anthropicPromptSanitize(_messages, _inputBodyObj, _outputObj) {
  if (typeof _messages === "string") {
    return [
      {
        role: "user",
        content: _messages
      }
    ];
  }
  const [first, ...messages] = [
    ..._messages.map((a) => ({
      ...a
    }))
  ];
  if (first.role === "system") {
    _outputObj.system = first.content;
    return messages;
  }
  return [
    first,
    ...messages
  ];
}
__name(anthropicPromptSanitize, "anthropicPromptSanitize");
var anthropicChatV1 = {
  key: "anthropic.chat.v1",
  provider: "anthropic.chat",
  endpoint: `https://api.anthropic.com/v1/messages`,
  headers: `{"x-api-key":"{{anthropicApiKey}}", "Content-Type": "application/json", "anthropic-version": "${ANTORPIC_VERSION}" }`,
  method: "POST",
  options: {
    prompt: {},
    system: {},
    maxTokens: {
      required: [
        true,
        "maxTokens required"
      ]
    },
    anthropicApiKey: {
      default: getEnvironmentVariable("ANTHROPIC_API_KEY")
    }
  },
  mapBody: {
    model: {
      key: "model"
    },
    maxTokens: {
      key: "max_tokens"
    },
    system: {
      key: "system"
    },
    prompt: {
      key: "messages",
      sanitize: anthropicPromptSanitize
    }
  }
};
var anthropic = {
  "anthropic.chat.v1": anthropicChatV1,
  "anthropic.claude-3-5-sonnet": withDefaultModel(anthropicChatV1, "claude-3-5-sonnet-20240620"),
  "anthropic.claude-3-opus": withDefaultModel(anthropicChatV1, "claude-3-opus-20240229"),
  "anthropic.claude-3-sonnet": withDefaultModel(anthropicChatV1, "claude-3-sonnet-20240229"),
  "anthropic.claude-3-haiku": withDefaultModel(anthropicChatV1, "claude-3-haiku-20240307")
};

// src/llm/config/bedrock/index.ts
var ANTORPIC_BEDROCK_VERSION = "bedrock-2023-05-31";
var amazonAnthropicChatV1 = {
  key: "amazon:anthropic.chat.v1",
  provider: "amazon:anthropic.chat",
  method: "POST",
  headers: `{"Content-Type": "application/json" }`,
  endpoint: `https://bedrock-runtime.{{awsRegion}}.amazonaws.com/model/{{model}}/invoke`,
  options: {
    prompt: {},
    topP: {},
    maxTokens: {},
    awsRegion: {
      default: getEnvironmentVariable("AWS_REGION"),
      required: [
        true,
        "aws region is required"
      ]
    },
    awsSecretKey: {},
    awsAccessKey: {}
  },
  mapBody: {
    prompt: {
      key: "messages",
      sanitize: anthropicPromptSanitize
    },
    topP: {
      key: "top_p"
    },
    maxTokens: {
      key: "max_tokens",
      default: 1e4
    },
    anthropic_version: {
      key: "anthropic_version",
      default: ANTORPIC_BEDROCK_VERSION
    }
  }
};
var amazonMetaChatV1 = {
  key: "amazon:meta.chat.v1",
  provider: "amazon:meta.chat",
  method: "POST",
  headers: `{"Content-Type": "application/json" }`,
  options: {
    prompt: {},
    topP: {},
    maxTokens: {},
    temperature: {},
    awsRegion: {
      default: getEnvironmentVariable("AWS_REGION")
    },
    awsSecretKey: {},
    awsAccessKey: {}
  },
  endpoint: `https://bedrock-runtime.{{awsRegion}}.amazonaws.com/model/{{model}}/invoke`,
  mapBody: {
    prompt: {
      key: "prompt",
      sanitize: /* @__PURE__ */ __name((messages) => {
        if (typeof messages === "string") {
          return messages;
        } else {
          return replaceTemplateString(`{{>DialogueHistory key='messages'}}`, {
            messages
          });
        }
      }, "sanitize")
    },
    topP: {
      key: "top_p"
    },
    temperature: {
      key: "temperature"
    },
    maxTokens: {
      key: "max_gen_len",
      default: 2048
    }
  }
};
var bedrock = {
  "amazon:anthropic.chat.v1": amazonAnthropicChatV1,
  "amazon:meta.chat.v1": amazonMetaChatV1
};

// src/llm/config.ts
var configs = {
  ...openai,
  ...anthropic,
  ...bedrock
};
function getLlmConfig(provider) {
  const pick2 = configs[provider];
  if (pick2) {
    return pick2;
  }
  throw new Error("Invalid provider");
}
__name(getLlmConfig, "getLlmConfig");

// src/llm/output/_utils/getResultContent.ts
function getResultContent(result, index) {
  if (index && index > 0) {
    const arr = result?.options || [];
    const val = arr[index];
    return val ? val : [];
  }
  return [
    ...result.content
  ];
}
__name(getResultContent, "getResultContent");

// src/llm/output/base.ts
function BaseLlmOutput2(result) {
  const __result = Object.freeze({
    id: result.id || (0, import_uuid.v4)(),
    name: result.name,
    usage: result.usage,
    stopReason: result.stopReason,
    options: [
      ...result?.options || []
    ],
    content: [
      ...result.content
    ],
    created: result?.created || (/* @__PURE__ */ new Date()).getTime()
  });
  function getResult() {
    return {
      id: __result.id,
      name: __result.name,
      created: __result.created,
      usage: __result.usage,
      options: __result.options,
      content: __result.content,
      stopReason: __result.stopReason
    };
  }
  __name(getResult, "getResult");
  return {
    getResultContent: /* @__PURE__ */ __name((index) => getResultContent(__result, index), "getResultContent"),
    getResultText: /* @__PURE__ */ __name(() => getResultText(__result.content), "getResultText"),
    getResult
  };
}
__name(BaseLlmOutput2, "BaseLlmOutput2");

// src/llm/output/_util.ts
function normalizeFunctionCall(input, provider) {
  if (input === "any") {
    if (provider === "openai") {
      return "required";
    }
  }
  return input;
}
__name(normalizeFunctionCall, "normalizeFunctionCall");
function formatOptions(response, handler) {
  const out = [];
  for (const item of response) {
    const result = handler(item);
    if (result) {
      out.push([
        result
      ]);
    }
  }
  return out;
}
__name(formatOptions, "formatOptions");
function formatContent(response, handler) {
  const out = [];
  const result = handler(response);
  if (result) {
    out.push(result);
  }
  return out;
}
__name(formatContent, "formatContent");

// src/llm/output/openai.ts
function formatResult(result) {
  if (typeof result?.message?.content === "string") {
    return {
      type: "text",
      text: result.message.content
    };
  } else if (result?.message && "tool_calls" in result.message) {
    const tool_calls = result.message.tool_calls;
    for (const call of tool_calls) {
      return {
        type: "function_use",
        name: call.function.name,
        input: JSON.parse(call.function.arguments)
      };
    }
  }
  return {
    type: "text",
    text: ""
  };
}
__name(formatResult, "formatResult");
function OutputOpenAIChat(result, _config) {
  const id = result.id;
  const name = result.model || _config?.model || "openai.unknown";
  const created = result.created;
  const [_content, ..._options] = result?.choices || [];
  const stopReason = _content?.finish_reason;
  const content = formatContent(_content, formatResult);
  const options = formatOptions(_options, formatResult);
  const usage = {
    output_tokens: result?.usage?.completion_tokens,
    input_tokens: result?.usage?.prompt_tokens,
    total_tokens: result?.usage?.total_tokens
  };
  return BaseLlmOutput2({
    id,
    name,
    created,
    usage,
    stopReason,
    content,
    options
  });
}
__name(OutputOpenAIChat, "OutputOpenAIChat");

// src/llm/output/claude.ts
function formatResult2(response) {
  const content = response?.content || [];
  const out = [];
  for (let i = 0; i < content.length; i++) {
    const result = content[i];
    if (result.type === "text") {
      out.push({
        type: "text",
        text: result.text
      });
    } else if (result.type === "tool_use") {
      out.push({
        type: "function_use",
        name: result.name,
        input: result.input
      });
    }
  }
  return out;
}
__name(formatResult2, "formatResult");
function OutputAnthropicClaude3Chat(result, _config) {
  const id = result.id;
  const name = result.model || _config?.model || "anthropic.unknown";
  const stopReason = result.stop_reason;
  const content = formatResult2(result);
  const usage = {
    input_tokens: result?.usage?.input_tokens,
    output_tokens: result?.usage?.output_tokens,
    total_tokens: result?.usage?.input_tokens + result?.usage?.input_tokens
  };
  return BaseLlmOutput2({
    id,
    name,
    usage,
    stopReason,
    content
  });
}
__name(OutputAnthropicClaude3Chat, "OutputAnthropicClaude3Chat");

// src/llm/output/llama.ts
function OutputMetaLlama3Chat(result, _config) {
  const name = _config?.model || "meta";
  const stopReason = result.stop_reason;
  const content = [
    {
      type: "text",
      text: result.generation
    }
  ];
  const usage = {
    output_tokens: result?.generation_token_count,
    input_tokens: result?.prompt_token_count,
    total_tokens: result?.generation_token_count + result?.prompt_token_count
  };
  return BaseLlmOutput2({
    name,
    usage,
    stopReason,
    content
  });
}
__name(OutputMetaLlama3Chat, "OutputMetaLlama3Chat");

// src/llm/output/default.ts
function OutputDefault(result, _config) {
  const name = _config.model || "unknown";
  const stopReason = result?.stopReason || "stop";
  const content = [];
  if (result?.text) {
    content.push({
      type: "text",
      text: result.text
    });
  }
  const usage = {
    output_tokens: result?.output_tokens || 0,
    input_tokens: result?.input_tokens || 0,
    total_tokens: (result?.input_tokens || 0) + (result?.output_tokens || 0)
  };
  return BaseLlmOutput2({
    name,
    usage,
    stopReason,
    content
  });
}
__name(OutputDefault, "OutputDefault");

// src/llm/output/index.ts
function getOutputParser(config, response) {
  switch (config?.key) {
    case "openai.chat.v1":
    case "openai.chat-mock.v1":
      return OutputOpenAIChat(response, config);
    case "anthropic.chat.v1":
    case "amazon:anthropic.chat.v1":
      return OutputAnthropicClaude3Chat(response, config);
    case "amazon:meta.chat.v1":
      return OutputMetaLlama3Chat(response, config);
    default: {
      if (config?.key?.startsWith("custom:")) {
        return OutputDefault(response, config);
      }
      throw new Error("Unsupported provider");
    }
  }
}
__name(getOutputParser, "getOutputParser");

// src/utils/modules/request.ts
async function apiRequest(url, options) {
  const finalOptions = {
    ...options
  };
  try {
    const response = await fetch(url, finalOptions);
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}. Error`);
    }
    const responseData = await response.json();
    return responseData;
  } catch (error) {
    const message = error instanceof Error ? error.message : "Error";
    throw new Error(`Request to ${url} failed: ${message}`);
  }
}
__name(apiRequest, "apiRequest");

// src/utils/modules/replaceTemplateStringSimple.ts
function replaceTemplateStringSimple(template, context) {
  return template.replace(/{{\s*([\w.]+)\s*}}/g, (_match, key) => {
    const keys = key.split(".");
    let value = context;
    for (const k of keys) {
      if (value && typeof value === "object" && k in value) {
        value = value[k];
      } else {
        return "";
      }
    }
    return typeof value === "string" ? value : String(value);
  });
}
__name(replaceTemplateStringSimple, "replaceTemplateStringSimple");

// src/utils/modules/convertDotNotation.ts
function convertDotNotation(obj) {
  const result = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (key.includes(".")) {
        const keys = key.split(".");
        let currentLevel = result;
        for (let i = 0; i < keys.length; i++) {
          if (i === keys.length - 1) {
            currentLevel[keys[i]] = obj[key];
          } else {
            currentLevel[keys[i]] = currentLevel[keys[i]] || {};
            currentLevel = currentLevel[keys[i]];
          }
        }
      } else {
        result[key] = obj[key];
      }
    }
  }
  return result;
}
__name(convertDotNotation, "convertDotNotation");

// src/llm/_utils.mapBody.ts
function mapBody(template, body) {
  const output = {};
  const keys = Object.keys(template);
  for (let i = 0; i < keys.length; i++) {
    const genericInputKey = keys[i];
    const providerSpecificSettings = template[genericInputKey];
    const { key: providerSpecificKey, default: defaultValue } = providerSpecificSettings;
    if (providerSpecificKey) {
      let valueForThisKey = body[genericInputKey];
      if (providerSpecificSettings.sanitize && typeof providerSpecificSettings.sanitize === "function") {
        valueForThisKey = providerSpecificSettings.sanitize(valueForThisKey, Object.freeze({
          ...body
        }), output);
      }
      if (typeof valueForThisKey !== "undefined") {
        output[providerSpecificKey] = valueForThisKey;
      } else if (typeof valueForThisKey === "undefined" && typeof defaultValue !== "undefined") {
        output[providerSpecificKey] = defaultValue;
      }
    }
  }
  return convertDotNotation(output);
}
__name(mapBody, "mapBody");

// src/utils/modules/getAwsAuthorizationHeaders.ts
var import_credential_providers = require("@aws-sdk/credential-providers");
var import_signature_v4 = require("@smithy/signature-v4");

// node_modules/@smithy/types/dist-es/auth/auth.js
var HttpAuthLocation;
(function(HttpAuthLocation2) {
  HttpAuthLocation2["HEADER"] = "header";
  HttpAuthLocation2["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

// node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
var HttpApiKeyAuthLocation;
(function(HttpApiKeyAuthLocation2) {
  HttpApiKeyAuthLocation2["HEADER"] = "header";
  HttpApiKeyAuthLocation2["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

// node_modules/@smithy/types/dist-es/endpoint.js
var EndpointURLScheme;
(function(EndpointURLScheme2) {
  EndpointURLScheme2["HTTP"] = "http";
  EndpointURLScheme2["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

// node_modules/@smithy/types/dist-es/extensions/checksum.js
var AlgorithmId;
(function(AlgorithmId2) {
  AlgorithmId2["MD5"] = "md5";
  AlgorithmId2["CRC32"] = "crc32";
  AlgorithmId2["CRC32C"] = "crc32c";
  AlgorithmId2["SHA1"] = "sha1";
  AlgorithmId2["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));

// node_modules/@smithy/types/dist-es/http.js
var FieldPosition;
(function(FieldPosition2) {
  FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
  FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

// node_modules/@smithy/types/dist-es/profile.js
var IniSectionType;
(function(IniSectionType2) {
  IniSectionType2["PROFILE"] = "profile";
  IniSectionType2["SSO_SESSION"] = "sso-session";
  IniSectionType2["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

// node_modules/@smithy/types/dist-es/transfer.js
var RequestHandlerProtocol;
(function(RequestHandlerProtocol2) {
  RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
  RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
  RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

// node_modules/@smithy/protocol-http/dist-es/httpRequest.js
var _HttpRequest = class _HttpRequest {
  constructor(options) {
    this.method = options.method || "GET";
    this.hostname = options.hostname || "localhost";
    this.port = options.port;
    this.query = options.query || {};
    this.headers = options.headers || {};
    this.body = options.body;
    this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
    this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
    this.username = options.username;
    this.password = options.password;
    this.fragment = options.fragment;
  }
  static clone(request) {
    const cloned = new _HttpRequest({
      ...request,
      headers: {
        ...request.headers
      }
    });
    if (cloned.query) {
      cloned.query = cloneQuery(cloned.query);
    }
    return cloned;
  }
  static isInstance(request) {
    if (!request) {
      return false;
    }
    const req = request;
    return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
  }
  clone() {
    return _HttpRequest.clone(this);
  }
};
__name(_HttpRequest, "HttpRequest");
var HttpRequest = _HttpRequest;
function cloneQuery(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [
        ...param
      ] : param
    };
  }, {});
}
__name(cloneQuery, "cloneQuery");

// src/utils/modules/getAwsAuthorizationHeaders.ts
var import_sha256_js = require("@aws-crypto/sha256-js");

// src/utils/modules/runWithTemporaryEnv.ts
async function runWithTemporaryEnv(env, handler) {
  const previousEnv = {
    ...process.env
  };
  try {
    env();
    const value = await handler();
    return value;
  } finally {
    process.env = previousEnv;
  }
}
__name(runWithTemporaryEnv, "runWithTemporaryEnv");

// src/utils/modules/getAwsAuthorizationHeaders.ts
async function getAwsAuthorizationHeaders(req, props) {
  const providerChain = (0, import_credential_providers.fromNodeProviderChain)();
  const credentials = await runWithTemporaryEnv(() => {
    if (props.awsAccessKey) {
      process.env["AWS_ACCESS_KEY_ID"] = props.awsAccessKey;
    }
    if (props.awsSecretKey) {
      process.env["AWS_SECRET_ACCESS_KEY"] = props.awsSecretKey;
    }
    if (props.awsSessionToken) {
      process.env["AWS_SESSION_TOKEN"] = props.awsSessionToken;
    }
  }, () => providerChain());
  const signer = new import_signature_v4.SignatureV4({
    service: "bedrock",
    region: props.regionName,
    credentials,
    sha256: import_sha256_js.Sha256
  });
  const url = new URL(props.url);
  const headers = !req.headers ? {} : Symbol.iterator in req.headers ? Object.fromEntries(Array.from(req.headers).map((header) => [
    ...header
  ])) : {
    ...req.headers
  };
  delete headers["connection"];
  headers["host"] = url.hostname;
  const request = new HttpRequest({
    method: req?.method?.toUpperCase(),
    protocol: url.protocol,
    path: url.pathname,
    body: req.body,
    headers
  });
  const signed = await signer.sign(request);
  return signed.headers;
}
__name(getAwsAuthorizationHeaders, "getAwsAuthorizationHeaders");

// src/llm/_utils.parseHeaders.ts
async function parseHeaders(config, replacements, payload) {
  const replace = replaceTemplateStringSimple(config.headers, replacements);
  const parse = replace ? JSON.parse(replace) : {};
  const headers = Object.assign({}, payload.headers, parse);
  if (config.provider.startsWith("amazon:") || config.provider.startsWith("amazon.")) {
    const url = payload.url;
    return getAwsAuthorizationHeaders({
      method: config.method,
      headers,
      body: payload.body
    }, {
      url,
      regionName: replacements?.awsRegion || getEnvironmentVariable("AWS_REGION"),
      awsSecretKey: replacements.awsSecretKey,
      awsAccessKey: replacements.awsAccessKey
    });
  } else {
    return headers;
  }
}
__name(parseHeaders, "parseHeaders");

// src/llm/output/_utils/cleanJsonSchemaFor.ts
var providerFieldExclusions = {
  "openai.chat": [
    "default"
  ]
};
function cleanJsonSchemaFor(schema = {}, provider) {
  const clone = deepClone(schema);
  const exclusions = providerFieldExclusions[provider] || [];
  function removeDisallowedFields(obj) {
    if (Array.isArray(obj)) {
      return obj.map(removeDisallowedFields);
    } else if (typeof obj === "object" && obj !== null) {
      return Object.keys(obj).reduce((acc, key) => {
        if (!exclusions.includes(key)) {
          acc[key] = removeDisallowedFields(obj[key]);
        }
        return acc;
      }, {});
    }
    return obj;
  }
  __name(removeDisallowedFields, "removeDisallowedFields");
  return removeDisallowedFields(clone);
}
__name(cleanJsonSchemaFor, "cleanJsonSchemaFor");

// src/llm/llm.call.ts
async function useLlm_call(state, messages, _options) {
  const config = getLlmConfig(state.key);
  const input = mapBody(config.mapBody, Object.assign({}, state, {
    prompt: messages
  }));
  if (_options && _options?.jsonSchema) {
    if (state.provider === "openai.chat") {
      const curr = input["response_format"] || {};
      const newObj = Object.assign(curr, {
        type: "json_schema",
        json_schema: {
          name: "output",
          schema: cleanJsonSchemaFor(_options?.jsonSchema, "openai.chat")
        }
      });
      if (typeof _options?.functionCallStrictInput === "undefined" || !!_options?.functionCallStrictInput) {
        newObj["json_schema"]["strict"] = true;
      }
      input["response_format"] = newObj;
    }
  }
  if (_options && _options?.functionCall) {
    if (state.provider === "anthropic.chat") {
      if (_options?.functionCall === "none") {
        _options.functions = [];
      } else if (_options?.functionCall === "auto" || _options?.functionCall === "any") {
        input["tool_choice"] = {
          type: _options?.functionCall
        };
      } else {
        input["tool_choice"] = _options?.functionCall;
      }
    } else if (state.provider === "openai.chat") {
      input["tool_choice"] = normalizeFunctionCall(_options?.functionCall, "openai");
    }
  }
  if (_options && _options?.functions?.length) {
    if (state.provider === "anthropic.chat") {
      input["tools"] = _options.functions.map((f) => ({
        name: f.name,
        description: f.description,
        input_schema: f.parameters
      }));
    } else if (state.provider === "openai.chat") {
      input["tools"] = _options.functions.map((f) => {
        const props = {
          name: f?.name,
          description: f?.description,
          parameters: f?.parameters
        };
        return {
          type: "function",
          function: Object.assign(props, {
            parameters: cleanJsonSchemaFor(props.parameters, "openai.chat")
          }, {
            strict: true
          })
        };
      });
    }
  }
  const body = JSON.stringify(input);
  const url = replaceTemplateStringSimple(config.endpoint, state);
  const headers = await parseHeaders(config, state, {
    url,
    headers: {},
    body
  });
  const response = config.provider === "openai.chat-mock" ? {
    id: "0123-45-6789",
    model: "model",
    created: (/* @__PURE__ */ new Date()).getTime(),
    usage: {
      completion_tokens: 0,
      prompt_tokens: 0,
      total_tokens: 0
    },
    choices: [
      {
        message: {
          role: "assistant",
          content: `Hello world from LLM! The input was ${JSON.stringify(messages)}`
        }
      }
    ]
  } : await apiRequest(url, {
    method: config.method,
    body,
    headers
  });
  return getOutputParser(state, response);
}
__name(useLlm_call, "useLlm_call");

// src/llm/_utils.stateFromOptions.ts
function stateFromOptions(options, config) {
  const optionsKeys = Object.keys(config.options);
  const state = Object.assign(pick(options, optionsKeys), {
    provider: config.provider,
    key: config.key,
    model: options.model
  });
  const keys = Object.keys(config.options);
  for (const key of keys) {
    const thisConfig = config.options[key];
    const thisValue = get(state, key);
    if (typeof thisValue === "undefined") {
      if (typeof thisConfig?.default !== "undefined") {
        state[key] = thisConfig.default;
      }
    }
    if (thisConfig?.required && typeof get(state, key) === "undefined") {
      const [required, message = `Error: [${key}] is required`] = thisConfig?.required;
      if (required) {
        throw new Error(message);
      }
    }
  }
  return state;
}
__name(stateFromOptions, "stateFromOptions");

// src/utils/modules/deepFreeze.ts
function deepFreeze(obj) {
  if (obj === null || obj === void 0) return obj;
  if (Object.isFrozen(obj)) return obj;
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  if (Array.isArray(obj)) {
    obj.forEach((item, index) => {
      obj[index] = deepFreeze(item);
    });
    return Object.freeze(obj);
  }
  if (typeof obj === "object" && obj !== null) {
    for (const key of Object.keys(obj)) {
      obj[key] = deepFreeze(obj[key]);
    }
    return Object.freeze(obj);
  }
  return obj;
}
__name(deepFreeze, "deepFreeze");

// src/utils/modules/requestWrapper.ts
var import_exponential_backoff = require("exponential-backoff");
function apiRequestWrapper(config, options, handler, doNotRetryErrorMessages = []) {
  const state = stateFromOptions(options, config);
  const metrics = {
    total_calls: 0,
    total_call_success: 0,
    total_call_retry: 0,
    total_call_error: 0,
    history: []
  };
  const timeout = options.timeout || 3e4;
  const maxDelay = options.maxDelay || 5e3;
  const numOfAttempts = options.numOfAttempts || 2;
  const jitter = options.jitter || "none";
  let traceId = options?.traceId || null;
  async function call(messages, options2) {
    try {
      metrics.total_calls++;
      const result = await (0, import_exponential_backoff.backOff)(() => asyncCallWithTimeout(handler(deepFreeze(state), deepFreeze(messages), deepFreeze(options2)), timeout), {
        startingDelay: 0,
        maxDelay,
        numOfAttempts,
        jitter,
        retry: /* @__PURE__ */ __name((_error, _stepNumber) => {
          if (doNotRetryErrorMessages.includes(_error.message)) {
            return false;
          }
          metrics.total_call_retry++;
          return true;
        }, "retry")
      });
      metrics.total_call_success++;
      return result;
    } catch (error) {
      metrics.total_call_error++;
      throw error;
    }
  }
  __name(call, "call");
  function getMetadata() {
    const { awsSecretKey, awsAccessKey, openAiApiKey, anthropicApiKey, ...rest } = options;
    return Object.assign({
      traceId: getTraceId(),
      timeout,
      jitter,
      maxDelay,
      numOfAttempts,
      metrics: {
        ...metrics
      }
    }, rest);
  }
  __name(getMetadata, "getMetadata");
  function getTraceId() {
    return traceId;
  }
  __name(getTraceId, "getTraceId");
  function withTraceId(id) {
    traceId = id;
  }
  __name(withTraceId, "withTraceId");
  return {
    call,
    getTraceId,
    withTraceId,
    getMetadata
  };
}
__name(apiRequestWrapper, "apiRequestWrapper");

// src/llm/llm.ts
function useLlm(provider, options = {}) {
  const config = getLlmConfig(provider);
  return apiRequestWrapper(config, options, useLlm_call);
}
__name(useLlm, "useLlm");

// src/embedding/config.ts
var embeddingConfigs = {
  "openai.embedding.v1": {
    key: "openai.embedding.v1",
    provider: "openai.embedding",
    endpoint: `https://api.openai.com/v1/embeddings`,
    method: "POST",
    headers: `{"Authorization":"Bearer {{openAiApiKey}}", "Content-Type": "application/json" }`,
    options: {
      input: {},
      dimensions: {},
      encodingFormat: {},
      openAiApiKey: {}
    },
    mapBody: {
      input: {
        key: "input"
      },
      model: {
        key: "model"
      },
      dimensions: {
        key: "dimensions"
      },
      encodingFormat: {
        key: "encoding_format"
      }
    }
  },
  "amazon.embedding.v1": {
    key: "amazon.embedding.v1",
    provider: "amazon.embedding",
    endpoint: `https://bedrock-runtime.{{awsRegion}}.amazonaws.com/model/{{model}}/invoke`,
    method: "POST",
    headers: `{"Content-Type": "application/json" }`,
    options: {
      input: {},
      dimensions: {},
      awsRegion: {
        default: getEnvironmentVariable("AWS_REGION"),
        required: [
          true,
          "aws region is required"
        ]
      },
      awsSecretKey: {},
      awsAccessKey: {}
    },
    mapBody: {
      input: {
        key: "inputText"
      },
      dimensions: {
        key: "dimensions"
      }
    }
  }
};
function getEmbeddingConfig(provider) {
  const pick2 = embeddingConfigs[provider];
  if (pick2) {
    return pick2;
  }
  throw new Error("Invalid provider");
}
__name(getEmbeddingConfig, "getEmbeddingConfig");

// src/embedding/output/BaseEmbeddingOutput.ts
function BaseEmbeddingOutput(result) {
  const __result = Object.freeze({
    id: result.id || (0, import_uuid.v4)(),
    model: result.model,
    usage: result.usage,
    embedding: [
      ...result?.embedding || []
    ],
    created: result?.created || (/* @__PURE__ */ new Date()).getTime()
  });
  function getResult() {
    return {
      id: __result.id,
      model: __result.model,
      created: __result.created,
      usage: __result.usage,
      embedding: __result.embedding
    };
  }
  __name(getResult, "getResult");
  function getEmbedding(index) {
    if (index && index > 0) {
      const arr = __result?.embedding;
      const val = arr[index];
      return val ? val : [];
    }
    return __result.embedding[0];
  }
  __name(getEmbedding, "getEmbedding");
  return {
    getEmbedding,
    getResult
  };
}
__name(BaseEmbeddingOutput, "BaseEmbeddingOutput");

// src/embedding/output/AmazonTitan.ts
function AmazonTitanEmbedding(result, config) {
  const __result = deepClone(result);
  const model = config.model || "amazon.unknown";
  const created = (/* @__PURE__ */ new Date()).getTime();
  const embedding = [
    __result.embedding
  ];
  const usage = {
    output_tokens: 0,
    input_tokens: __result.inputTextTokenCount,
    total_tokens: __result.inputTextTokenCount
  };
  return BaseEmbeddingOutput({
    model,
    created,
    usage,
    embedding
  });
}
__name(AmazonTitanEmbedding, "AmazonTitanEmbedding");

// src/embedding/output/OpenAiEmbedding.ts
function OpenAiEmbedding(result, config) {
  const __result = deepClone(result);
  const model = __result.model || config.model || "openai.unknown";
  const created = (/* @__PURE__ */ new Date()).getTime();
  const results = result?.data || [];
  const embedding = results.map((a) => a.embedding);
  const usage = {
    output_tokens: 0,
    input_tokens: result?.usage?.prompt_tokens,
    total_tokens: result?.usage?.total_tokens
  };
  return BaseEmbeddingOutput({
    model,
    created,
    usage,
    embedding
  });
}
__name(OpenAiEmbedding, "OpenAiEmbedding");

// src/embedding/output/getEmbeddingOutputParser.ts
function getEmbeddingOutputParser(config, response) {
  switch (config.key) {
    case "openai.embedding.v1":
      return OpenAiEmbedding(response, config);
    case "amazon.embedding.v1":
      return AmazonTitanEmbedding(response, config);
    default:
      throw new Error("Unsupported provider");
  }
}
__name(getEmbeddingOutputParser, "getEmbeddingOutputParser");

// src/embedding/embedding.call.ts
async function createEmbedding_call(state, _input, _options) {
  const config = getEmbeddingConfig(state.key);
  const input = mapBody(config.mapBody, Object.assign({}, state, {
    input: _input
  }));
  const body = JSON.stringify(input);
  const url = replaceTemplateStringSimple(config.endpoint, state);
  const headers = await parseHeaders(config, state, {
    url,
    headers: {},
    body
  });
  const request = await apiRequest(url, {
    method: config.method,
    body,
    headers
  });
  return getEmbeddingOutputParser(state, request);
}
__name(createEmbedding_call, "createEmbedding_call");

// src/embedding/embedding.ts
function createEmbedding(provider, options) {
  const config = getEmbeddingConfig(provider);
  return apiRequestWrapper(config, options, createEmbedding_call);
}
__name(createEmbedding, "createEmbedding");

// src/prompt/_base.ts
var _BasePrompt = class _BasePrompt {
  /**
  * constructor description
  * @param initialPromptMessage An initial message to add to the prompt.
  */
  constructor(initialPromptMessage, options) {
    __publicField(this, "type", "text");
    __publicField(this, "messages", []);
    __publicField(this, "partials", []);
    __publicField(this, "helpers", []);
    __publicField(this, "replaceTemplateString", replaceTemplateString);
    __publicField(this, "replaceTemplateStringAsync", replaceTemplateStringAsync);
    __publicField(this, "filters", {
      pre: [],
      post: []
    });
    if (initialPromptMessage) {
      this.addToPrompt(initialPromptMessage, "system");
    }
    if (options) {
      if (options.partials) {
        this.registerPartial(options.partials);
      }
      if (options.helpers) {
        this.registerHelpers(options.helpers);
      }
      if (options.preFilters && Array.isArray(options.preFilters)) {
        this.filters.pre.push(...options.preFilters);
      }
      if (options.postFilters && Array.isArray(options.postFilters)) {
        this.filters.post.push(...options.postFilters);
      }
      if (options.replaceTemplateString) {
        this.replaceTemplateString = options.replaceTemplateString;
      }
    }
  }
  /**
  * addToPrompt description
  * @param content The message content
  * @param role The role of the user. Defaults to system for base text prompt.
  * @return instance of BasePrompt.
  */
  addToPrompt(content, role = "system") {
    if (content) {
      switch (role) {
        case "system":
        default:
          this.addSystemMessage(content);
          break;
      }
    }
    return this;
  }
  /**
  * addSystemMessage description
  * @param content The message content
  * @return returns BasePrompt so it can be chained.
  */
  addSystemMessage(content) {
    this.messages.push({
      role: "system",
      content
    });
    return this;
  }
  /**
  * registerPartial description
  * @param partialOrPartials Additional partials that can be made available to the template parser.
  * @return BasePrompt so it can be chained.
  */
  registerPartial(partialOrPartials) {
    const partials2 = Array.isArray(partialOrPartials) ? partialOrPartials : [
      partialOrPartials
    ];
    this.partials.push(...partials2);
    return this;
  }
  /**
  * registerHelpers description
  * @param helperOrHelpers Additional helper functions that can be made available to the template parser.
  * @return BasePrompt so it can be chained.
  */
  registerHelpers(helperOrHelpers) {
    const helpers = Array.isArray(helperOrHelpers) ? helperOrHelpers : [
      helperOrHelpers
    ];
    this.helpers.push(...helpers);
    return this;
  }
  /**
  * format description
  * @param values The message content
  * @param separator The separator between messages. defaults to "\n\n"
  * @return returns messages formatted with template replacement
  */
  format(values, separator = "\n\n") {
    const replacements = this.getReplacements(values);
    const messages = this.messages.map((message) => {
      return message.content && !Array.isArray(message.content) ? this.replaceTemplateString(this.runPromptFilter(message.content, this.filters.pre, values), replacements, {
        partials: this.partials,
        helpers: this.helpers
      }) : "";
    }).join(separator);
    return this.runPromptFilter(messages, this.filters.post, values);
  }
  /**
  * format description
  * @param values The message content
  * @param separator The separator between messages. defaults to "\n\n"
  * @return returns messages formatted with template replacement
  */
  async formatAsync(values, separator = "\n\n") {
    const replacements = this.getReplacements(values);
    const _messages = await Promise.all(this.messages.map((message) => {
      return message.content && !Array.isArray(message.content) ? this.replaceTemplateStringAsync(this.runPromptFilter(message.content, this.filters.pre, values), replacements, {
        partials: this.partials,
        helpers: this.helpers
      }) : "";
    }));
    const messages = _messages.join(separator);
    return this.runPromptFilter(messages, this.filters.post, values);
  }
  runPromptFilter(prompt, filters, values) {
    let promptValue = prompt;
    for (const filter of filters) {
      promptValue = filter(promptValue, values);
    }
    return promptValue;
  }
  getReplacements(values) {
    const { input = "", ...restOfValues } = values;
    const replacements = Object.assign({}, {
      ...restOfValues
    }, {
      input,
      _input: input
    });
    return replacements;
  }
  /**
  * validate description
  * @return {boolean} Returns false if the template is not valid.
  */
  validate() {
    return true;
  }
};
__name(_BasePrompt, "BasePrompt");
var BasePrompt = _BasePrompt;

// src/prompt/text.ts
var _TextPrompt = class _TextPrompt extends BasePrompt {
  constructor(base, options) {
    super(base, options);
  }
};
__name(_TextPrompt, "TextPrompt");
var TextPrompt = _TextPrompt;

// src/utils/modules/unescape.ts
function unescape(str) {
  const map = {
    "&amp;": "&",
    "&lt;": "<",
    "&gt;": ">",
    "&quot;": '"',
    "&#39;": "'"
  };
  const entityRegex = /&amp;|&lt;|&gt;|&quot;|&#39;/g;
  return str.replace(entityRegex, (m) => map[m]);
}
__name(unescape, "unescape");

// src/utils/modules/extractPromptPlaceholderToken.ts
function extractPromptPlaceholderToken(tok) {
  if (!tok) return {
    token: ""
  };
  const token = tok.replace(/ /g, "");
  if (token.substring(2, 18) === ">DialogueHistory") {
    const matchKey = tok.match(/key=(['"`])((?:(?!\1).)*)\1/);
    const matchAssistant = tok.match(/assistant=(['"`])((?:(?!\1).)*)\1/);
    const matchUser = tok.match(/user=(['"`])((?:(?!\1).)*)\1/);
    if (matchKey) {
      return {
        token: ">DialogueHistory",
        key: matchKey[2],
        assistant: matchAssistant ? get(matchAssistant, "[2]", "") : void 0,
        user: matchUser ? get(matchUser, "[2]", "") : matchUser
      };
    }
  } else if (token.substring(2, 20) === ">SingleChatMessage") {
    const matchRole = tok.match(/role=(['"`])((?:(?!\1).)*)\1/);
    const matchContent = tok.match(/content=(['"`])((?:(?!\1).)*)\1/);
    const matchName = tok.match(/name=(['"`])((?:(?!\1).)*)\1/);
    if (matchRole) {
      return {
        token: ">SingleChatMessage",
        name: matchName ? get(matchName, "[2]") : void 0,
        content: matchContent ? unescape(get(matchContent, "[2]", "")) : void 0,
        role: get(matchRole, "[2]", "")
      };
    }
  }
  return {
    token: ""
  };
}
__name(extractPromptPlaceholderToken, "extractPromptPlaceholderToken");

// src/utils/modules/escape.ts
function escape(str) {
  const map = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  return str.replace(/[&<>"']/g, (m) => map[m]);
}
__name(escape, "escape");

// src/prompt/chat.ts
var _ChatPrompt = class _ChatPrompt extends BasePrompt {
  /**
  * new `ChatPrompt`
  * @param initialSystemPromptMessage (optional) An initial system message to add to the new prompt.
  * @param options (optional) Options to pass in when creating the prompt.
  */
  constructor(initialSystemPromptMessage, options) {
    super(initialSystemPromptMessage, options);
    /**
    * @property type - Prompt type (chat)
    */
    __publicField(this, "type", "chat");
    /**
    * @property parseUserTemplates - Whether or not to allow parsing
    * user messages with the template engine. This could be a risk,
    * so we only parse user messages if explicitly set.
    */
    __publicField(this, "parseUserTemplates", false);
    if (options?.allowUnsafeUserTemplate) {
      this.parseUserTemplates = true;
    }
  }
  addToPrompt(content, role, name) {
    if (content) {
      switch (role) {
        case "system":
          this.addSystemMessage(content);
          break;
        case "user":
          this.addUserMessage(content, name);
          break;
        case "assistant":
          this.addAssistantMessage(content);
          break;
        case "function":
          assert(name, "Function message requires name");
          this.addFunctionMessage(content, name);
          break;
        case "function_call":
          assert(name, "Function message requires name");
          this.addFunctionCallMessage({
            name,
            arguments: content
          });
          break;
      }
    }
    return this;
  }
  /**
  * addUserMessage Helper to add a user message to the prompt.
  * @param content The message content.
  * @param name (optional) The name of the user.
  * @return instance of ChatPrompt.
  */
  addUserMessage(content, name) {
    const message = {
      role: "user",
      content
    };
    if (name) {
      message.name = name;
    }
    this.messages.push(message);
    return this;
  }
  /**
  * addAssistantMessage Helper to add an assistant message to the prompt.
  * @param content The message content.
  * @return ChatPrompt so it can be chained.
  */
  addAssistantMessage(content) {
    this.messages.push({
      role: "assistant",
      content
    });
    return this;
  }
  /**
  * addFunctionMessage Helper to add an assistant message to the prompt.
  * @param content The message content.
  * @return ChatPrompt so it can be chained.
  */
  addFunctionMessage(content, name) {
    this.messages.push({
      role: "function",
      name,
      content
    });
    return this;
  }
  /**
  * addFunctionCallMessage Helper to add an assistant message to the prompt.
  * @param content The message content.
  * @return ChatPrompt so it can be chained.
  */
  addFunctionCallMessage(function_call) {
    if (function_call) {
      this.messages.push({
        role: "assistant",
        function_call: {
          name: function_call.name,
          arguments: maybeStringifyJSON(function_call.arguments)
        },
        content: null
      });
    }
    return this;
  }
  /**
  * addFromHistory Adds multiple messages at one time.
  * @param history History of chat messages.
  * @return ChatPrompt so it can be chained.
  */
  addFromHistory(history) {
    if (history && Array.isArray(history)) {
      for (const message of history) {
        switch (message.role) {
          case "user":
            this.addUserMessage(message.content, message?.name);
            break;
          case "assistant":
            if (message.function_call) {
              this.addFunctionCallMessage(message.function_call);
            } else if (message?.content) {
              this.addAssistantMessage(message?.content);
            }
            break;
          case "system":
            this.addSystemMessage(message.content);
            break;
          case "function":
            this.addFunctionMessage(message.content, message.name);
            break;
        }
      }
    }
    return this;
  }
  /**
  * addPlaceholder description
  * @param content The message content
  * @return returns ChatPrompt so it can be chained.
  */
  addChatHistoryPlaceholder(key, options) {
    const start = `{{> DialogueHistory `;
    const params = [
      `key='${String(key)}'`
    ];
    const end = `}}`;
    if (options?.assistant) {
      params.push(`assistant='${options.assistant}'`);
    }
    if (options?.user) {
      params.push(`user='${options.user}'`);
    }
    this.messages.push({
      role: "placeholder",
      content: `${start}${params.join(" ")}${end}`
    });
    return this;
  }
  /**
  * addTokenPlaceholder description
  * @param content The message content
  * @return returns ChatPrompt so it can be chained.
  */
  addMessagePlaceholder(content, role = "user", name) {
    if (content) {
      const start = `{{> SingleChatMessage `;
      const params = [
        `role='${role}'`,
        `content='${escape(content)}'`
      ];
      const end = `}}`;
      if (name) {
        params.push(`name='${name}'`);
      }
      this.messages.push({
        role: "placeholder",
        content: `${start}${params.join(" ")}${end}`
      });
    }
    return this;
  }
  _format_placeholderDialogueHistory(data, replacements) {
    const messagesOut = [];
    const { key = "", user } = data;
    const history = get(replacements, key, []);
    if (history && Array.isArray(history)) {
      for (const message of history) {
        switch (message.role) {
          case "user": {
            const m = pick(message, [
              "role",
              "content",
              "name"
            ]);
            if (user) {
              m["name"] = user;
            }
            messagesOut.push(m);
            break;
          }
          case "assistant": {
            if (message.function_call) {
              messagesOut.push({
                role: "assistant",
                content: null,
                function_call: message.function_call
              });
            } else if (message?.content) {
              messagesOut.push({
                role: "assistant",
                content: message.content
              });
            }
            break;
          }
          case "function":
            messagesOut.push({
              role: "function",
              name: message.name,
              content: message.content
            });
            break;
          case "system":
            messagesOut.push({
              role: "system",
              content: message.content
            });
            break;
        }
      }
    }
    return messagesOut;
  }
  /**
  * format formats the stored prompt based on input values.
  * Uses template engine.
  * Output is intended for LLM.
  * @param values input values.
  * @return formatted prompt.
  */
  format(values) {
    const messagesOut = [];
    const replacements = this.getReplacements(values);
    const safeToParseTemplate = [
      "assistant",
      "system"
    ];
    if (this.parseUserTemplates) {
      safeToParseTemplate.push("user");
    }
    for (const message of this.messages) {
      if (message.role === "placeholder") {
        const tokenData = extractPromptPlaceholderToken(message.content);
        switch (tokenData.token) {
          case ">DialogueHistory": {
            messagesOut.push(...this._format_placeholderDialogueHistory(tokenData, replacements));
            break;
          }
          case ">SingleChatMessage": {
            const { name, content, role } = tokenData;
            if (role && content) {
              const message2 = {
                role,
                name,
                content: this.replaceTemplateString(content, replacements, {
                  partials: this.partials,
                  helpers: this.helpers
                })
              };
              if (!name || role !== "user") {
                delete message2.name;
              }
              messagesOut.push(message2);
            }
            break;
          }
        }
      } else if (message.role === "function") {
        messagesOut.push(Object.assign({}, message, {
          content: this.replaceTemplateString(message.content, replacements, {
            partials: this.partials,
            helpers: this.helpers
          })
        }));
      } else {
        if (safeToParseTemplate.includes(message.role)) {
          if (Array.isArray(message.content)) {
            const content = message.content.map((m) => m.text ? {
              type: "text",
              text: this.runPromptFilter(this.replaceTemplateString(this.runPromptFilter(m.text, this.filters.pre, values), replacements, {
                partials: this.partials,
                helpers: this.helpers
              }), this.filters.post, values)
            } : m);
            messagesOut.push(Object.assign({}, message, {
              content
            }));
          } else if (message.content) {
            const content = this.runPromptFilter(this.replaceTemplateString(this.runPromptFilter(message.content, this.filters.pre, values), replacements, {
              partials: this.partials,
              helpers: this.helpers
            }), this.filters.post, values);
            messagesOut.push(Object.assign({}, message, {
              content
            }));
          } else {
            messagesOut.push(Object.assign({}, message, {
              content: null
            }));
          }
        } else {
          messagesOut.push(Object.assign({}, message, {
            content: Array.isArray(message.content) ? message.content.map((m) => m.text ? {
              type: "text",
              text: this.runPromptFilter(this.runPromptFilter(m.text, this.filters.pre, values), this.filters.post, values)
            } : m) : message.content && !Array.isArray(message.content) ? this.runPromptFilter(this.runPromptFilter(message.content, this.filters.pre, values), this.filters.post, values) : null
          }));
        }
      }
    }
    return messagesOut;
  }
  /**
  * format formats the stored prompt based on input values.
  * Uses template engine.
  * Output is intended for LLM.
  * @param values input values.
  * @return formatted prompt.
  */
  async formatAsync(values) {
    const messagesOut = [];
    const replacements = this.getReplacements(values);
    const safeToParseTemplate = [
      "assistant",
      "system"
    ];
    if (this.parseUserTemplates) {
      safeToParseTemplate.push("user");
    }
    for (const message of this.messages) {
      if (message.role === "placeholder") {
        const { token, ...data } = extractPromptPlaceholderToken(message.content);
        switch (token) {
          case ">DialogueHistory": {
            const { key = "", user } = data;
            const history = get(replacements, key, []);
            if (history && Array.isArray(history)) {
              for (const message2 of history) {
                switch (message2.role) {
                  case "user": {
                    const m = pick(message2, [
                      "role",
                      "content",
                      "name"
                    ]);
                    if (user) {
                      m["name"] = user;
                    }
                    messagesOut.push(m);
                    break;
                  }
                  case "assistant": {
                    if (message2.function_call) {
                      messagesOut.push({
                        role: "assistant",
                        content: null,
                        function_call: message2.function_call
                      });
                    } else if (message2?.content) {
                      messagesOut.push({
                        role: "assistant",
                        content: message2.content
                      });
                    }
                    break;
                  }
                  case "function":
                    messagesOut.push({
                      role: "function",
                      name: message2.name,
                      content: message2.content
                    });
                    break;
                  case "system":
                    messagesOut.push({
                      role: "system",
                      content: message2.content
                    });
                    break;
                }
              }
            }
            break;
          }
          case ">SingleChatMessage": {
            const { name, content, role } = data;
            if (role && content) {
              const message2 = {
                role,
                name,
                content: await this.replaceTemplateStringAsync(content, replacements, {
                  partials: this.partials,
                  helpers: this.helpers
                })
              };
              if (!name || role !== "user") {
                delete message2.name;
              }
              messagesOut.push(message2);
            }
            break;
          }
        }
      } else if (message.role === "function") {
        messagesOut.push(Object.assign({}, message, {
          content: await this.replaceTemplateStringAsync(message.content, replacements, {
            partials: this.partials,
            helpers: this.helpers
          })
        }));
      } else {
        if (safeToParseTemplate.includes(message.role)) {
          if (Array.isArray(message.content)) {
            const content = [];
            for (const m of message.content) {
              if (m.text) {
                content.push({
                  type: "text",
                  text: this.runPromptFilter(
                    // HERE
                    await this.replaceTemplateStringAsync(this.runPromptFilter(m.text, this.filters.pre, values), replacements, {
                      partials: this.partials,
                      helpers: this.helpers
                    }),
                    this.filters.post,
                    values
                  )
                });
              } else {
                content.push(m);
              }
            }
            messagesOut.push(Object.assign({}, message, {
              content
            }));
          } else if (message.content) {
            const content = this.runPromptFilter(await this.replaceTemplateStringAsync(this.runPromptFilter(message.content, this.filters.pre, values), replacements, {
              partials: this.partials,
              helpers: this.helpers
            }), this.filters.post, values);
            messagesOut.push(Object.assign({}, message, {
              content
            }));
          } else {
            messagesOut.push(Object.assign({}, message, {
              content: null
            }));
          }
        } else {
          messagesOut.push(Object.assign({}, message, {
            content: Array.isArray(message.content) ? message.content.map((m) => m.text ? {
              type: "text",
              text: this.runPromptFilter(this.runPromptFilter(m.text, this.filters.pre, values), this.filters.post, values)
            } : m) : message.content && !Array.isArray(message.content) ? this.runPromptFilter(this.runPromptFilter(message.content, this.filters.pre, values), this.filters.post, values) : null
          }));
        }
      }
    }
    return messagesOut;
  }
  /**
  * validate Ensures there are not unresolved tokens in prompt.
  * @TODO Make this work!
  * @return Returns false if the template is not valid.
  */
  validate() {
    return true;
  }
};
__name(_ChatPrompt, "ChatPrompt");
var ChatPrompt = _ChatPrompt;

// src/prompt/_functions.ts
function createPrompt(type, initialPromptMessage, options) {
  switch (type) {
    case "chat":
      return new ChatPrompt(initialPromptMessage, options);
    default:
      return new TextPrompt(initialPromptMessage);
  }
}
__name(createPrompt, "createPrompt");
function createChatPrompt(initialSystemPromptMessage, options) {
  return new ChatPrompt(initialSystemPromptMessage, options);
}
__name(createChatPrompt, "createChatPrompt");

// src/state/item.ts
var _BaseStateItem = class _BaseStateItem {
  constructor(key, initialValue) {
    __publicField(this, "key");
    __publicField(this, "value");
    __publicField(this, "initialValue");
    this.key = key;
    this.value = initialValue;
    this.initialValue = initialValue;
  }
  setValue(value) {
    assert(typeof value === typeof this.value, `Invalid value type. Expected ${typeof this.value}, received ${typeof value}`);
    this.value = value;
  }
  getKey() {
    return this.key;
  }
  getValue() {
    return this.value;
  }
  resetValue() {
    this.value = this.initialValue;
  }
  serializeValue() {
    return {
      [this.getKey()]: this.getValue()
    };
  }
  serialize() {
    return {
      class: "BaseStateItem",
      name: this.getKey(),
      value: this.serializeValue()
    };
  }
};
__name(_BaseStateItem, "BaseStateItem");
var BaseStateItem = _BaseStateItem;
var _DefaultStateItem = class _DefaultStateItem extends BaseStateItem {
  constructor(name, defaultValue) {
    super(name, defaultValue);
  }
};
__name(_DefaultStateItem, "DefaultStateItem");
var DefaultStateItem = _DefaultStateItem;

// src/state/dialogue.ts
var _Dialogue = class _Dialogue extends BaseStateItem {
  constructor(name) {
    super(name, []);
    __publicField(this, "name");
    this.name = name;
  }
  setUserMessage(content, name) {
    if (content) {
      const msg = {
        role: "user",
        content
      };
      if (name) {
        msg.name = name;
      }
      this.value.push(msg);
    }
    return this;
  }
  setAssistantMessage(content) {
    if (content) {
      this.value.push({
        role: "assistant",
        content
      });
    }
    return this;
  }
  setSystemMessage(content) {
    if (content) {
      this.value.push({
        role: "system",
        content
      });
    }
    return this;
  }
  setFunctionMessage(content, name) {
    if (content) {
      this.value.push({
        role: "function",
        name,
        content
      });
    }
    return this;
  }
  setFunctionCallMessage(input) {
    this.value.push({
      role: "assistant",
      function_call: {
        name: input?.function_call.name,
        arguments: maybeStringifyJSON(input?.function_call.arguments)
      },
      content: null
    });
    return this;
  }
  setMessageTurn(userMessage, assistantMessage, systemMessage = "") {
    this.setUserMessage(userMessage);
    this.setAssistantMessage(assistantMessage);
    this.setSystemMessage(systemMessage);
    return this;
  }
  setHistory(messages) {
    for (const message of messages) {
      switch (message?.role) {
        case "user":
          this.setUserMessage(message?.content, message?.name);
          break;
        case "assistant":
          if (message.function_call) {
            this.setFunctionCallMessage({
              function_call: message.function_call
            });
          } else if (message?.content) {
            this.setAssistantMessage(message?.content);
          }
          break;
        case "system":
          this.setSystemMessage(message?.content);
          break;
        case "function":
          this.setFunctionMessage(message?.content, message.name);
          break;
      }
    }
    return this;
  }
  getHistory() {
    return this.getValue();
  }
  serialize() {
    return {
      class: "Dialogue",
      name: this.name,
      value: [
        ...this.value
      ]
    };
  }
};
__name(_Dialogue, "Dialogue");
var Dialogue = _Dialogue;

// src/state/_base.ts
var _BaseState = class _BaseState {
  constructor() {
    __publicField(this, "dialogues", {});
    __publicField(this, "attributes", {});
    __publicField(this, "context", {});
  }
  createDialogue(name = "defaultDialogue") {
    assert(!this.dialogues[name], `Dialogue already exists`);
    this.dialogues[name] = new Dialogue(name);
    return this.dialogues[name];
  }
  useDialogue(name = "defaultDialogue") {
    const dialogue = this.dialogues[name];
    if (!dialogue) {
      this.dialogues[name] = new Dialogue(name);
      return this.dialogues[name];
    }
    return dialogue;
  }
  getDialogue(name = "defaultDialogue") {
    const dialogue = this.dialogues[name];
    assert(dialogue, `Invalid dialogue ${name}`);
    return dialogue;
  }
  createContextItem(item) {
    assert(item instanceof BaseStateItem, "Invalid context item. Must be instance of BaseStateItem");
    assert(!this.context[item?.getKey()], `key (${item?.getKey()}) already exists`);
    this.context[item.getKey()] = item;
    return this.context[item.getKey()];
  }
  getContext(key) {
    return this.context[key];
  }
  getContextValue(key) {
    return this.context[key]?.getValue();
  }
  setAttribute(key, value) {
    this.attributes[key] = value;
  }
  deleteAttribute(key) {
    delete this.attributes[key];
  }
  clearAttributes() {
    this.attributes = {};
  }
  serialize() {
    const dialogues = {};
    const context = {};
    const attributes = {
      ...this.attributes
    };
    const dialogueKeys = Object.keys(this.dialogues);
    for (const dialogueKey of dialogueKeys) {
      dialogues[dialogueKey] = this.dialogues[dialogueKey].serialize();
    }
    const contextKeys = Object.keys(this.context);
    for (const contextKey of contextKeys) {
      context[contextKey] = this.context[contextKey].serialize();
    }
    return {
      dialogues,
      context,
      attributes
    };
  }
};
__name(_BaseState, "BaseState");
var BaseState = _BaseState;
var _DefaultState = class _DefaultState extends BaseState {
  constructor() {
    super();
  }
  async saveState() {
    console.log("Save not implemented in default state.");
  }
};
__name(_DefaultState, "DefaultState");
var DefaultState = _DefaultState;

// src/state/_functions.ts
function createState() {
  return new DefaultState();
}
__name(createState, "createState");
function createDialogue(name) {
  return new Dialogue(name);
}
__name(createDialogue, "createDialogue");
function createStateItem(name, defaultValue) {
  return new DefaultStateItem(name, defaultValue);
}
__name(createStateItem, "createStateItem");

// src/index.ts
var llmExe = {};
var src_default = llmExe;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BaseExecutor,
  BaseParser,
  BasePrompt,
  BaseStateItem,
  ChatPrompt,
  CustomParser,
  DefaultState,
  DefaultStateItem,
  LlmExecutorOpenAiFunctions,
  OpenAiFunctionParser,
  TextPrompt,
  createCallableExecutor,
  createChatPrompt,
  createCoreExecutor,
  createCustomParser,
  createDialogue,
  createEmbedding,
  createLlmExecutor,
  createParser,
  createPrompt,
  createState,
  createStateItem,
  useExecutors,
  useLlm,
  utils
});
